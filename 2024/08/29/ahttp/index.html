<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 7.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Hypertext Transfer Protocol (HTTP) 🌐 - H-sediment</title>

  
    <meta name="description" content="“鱼总是最后看见水的” - 理解 HTTP 协议本质与应用">
<meta property="og:type" content="article">
<meta property="og:title" content="Hypertext Transfer Protocol (HTTP) 🌐">
<meta property="og:url" content="http://example.com/2024/08/29/ahttp/index.html">
<meta property="og:site_name" content="H-sediment">
<meta property="og:description" content="“鱼总是最后看见水的” - 理解 HTTP 协议本质与应用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/20240905120540.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/20240905120929.png">
<meta property="article:published_time" content="2024-08-28T16:00:00.000Z">
<meta property="article:modified_time" content="2024-10-16T06:02:43.796Z">
<meta property="article:author" content="hcjjj">
<meta property="article:tag" content="HTTP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/20240905120540.png">
  
  
  
  <meta name="keywords" content="HTTP">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/icon.png">
  

  

  
    <link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
    <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
    <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"onload="renderMathInElement(document.body);"></script>
  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">H-sediment</div><div class="sub cap">dust in the wind</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/about/">About</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">Hypertext Transfer Protocol (HTTP) 🌐</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">网络分层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.</span> <span class="toc-text">HTTP 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.</span> <span class="toc-text">HTTP 相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">HTTP 报文结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.6.</span> <span class="toc-text">常用状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.7.</span> <span class="toc-text">HTTP 的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%9A%84%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.</span> <span class="toc-text">HTTP 的实体数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">HTTP 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">传输大文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">连接管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%B7%B3%E8%BD%AC"><span class="toc-number">2.3.</span> <span class="toc-text">重定向和跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">Cookie 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">缓存控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.6.</span> <span class="toc-text">代理服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS"><span class="toc-number">3.</span> <span class="toc-text">HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSL-TLS"><span class="toc-number">3.1.</span> <span class="toc-text">SSL&#x2F;TLS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">3.2.</span> <span class="toc-text">对称与非对称加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%B8%8E%E8%AF%81%E4%B9%A6"><span class="toc-number">3.3.</span> <span class="toc-text">数字签名与证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS-1-2-%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">TLS 1.2 连接过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLS-1-3-%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90"><span class="toc-number">3.5.</span> <span class="toc-text">TLS 1.3 特性解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Other-Points"><span class="toc-number">4.</span> <span class="toc-text">Other Points</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2"><span class="toc-number">4.1.</span> <span class="toc-text">HTTP 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-3"><span class="toc-number">4.2.</span> <span class="toc-text">HTTP 3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NGINX"><span class="toc-number">4.3.</span> <span class="toc-text">NGINX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WAF"><span class="toc-number">4.4.</span> <span class="toc-text">WAF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN"><span class="toc-number">4.5.</span> <span class="toc-text">CDN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket"><span class="toc-number">4.6.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.7.</span> <span class="toc-text">HTTP 性能优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></widget>




</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/hcjjj" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg"/></a><a class="social" href="/hcjjj@foxmail.com" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg"/></a><a class="social" href="/H_sediment" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg"/></a><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3845874.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      


  
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@v10/dist/mermaid.min.js"></script>

  <script>
    var mermaid_config = {
      startOnLoad: true,
      theme:
        "auto" == "auto" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "neutral",
      logLevel: 3,
      themeVariables: {
        darkMode: true
      },
      flowchart: {
        useMaxWidth: false,
        htmlLabels: true,
        curve: "linear"
      },
      gantt: {
        axisFormat: "%Y/%m/%d"
      },
      sequence: {
        actorMargin: 50
      }
    }
    if (window.mermaid) {
      mermaid.initialize(mermaid_config);
    }
  </script>




<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Network/">Network</a></div><div id="post-meta">发布于&nbsp;<time datetime="2024-08-28T16:00:00.000Z">2024-08-29</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>Hypertext Transfer Protocol (HTTP) 🌐</span></h1>
<p>“鱼总是最后看见水的” - 理解 HTTP 协议本质与应用</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h3><p><strong>TCP&#x2F;IP 网络分层模型</strong></p>
<p>“分层”的概念，把复杂的网络通信划分出多个层次，再给每一个层次分配不同的职责，层次内只专心做自己的事情就好，用“分而治之”的思想把一个“大麻烦”拆分成了数个“小麻烦”，从而解决了网络通信的难题。</p>
<pre class="mermaid">graph TB
        link_layer["link layer/MAC"]
        internet_layer["internet layer/IP"]
        transport_layer["transport Layer/TCP/UDP"]
        application_layer["application layer/HTTP"]</pre>

<ul>
<li><p>链接层（link layer）负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层</p>
</li>
<li><p>网际层或网络互连层（internet layer）在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了</p>
<p>传输层（transport layer）的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP （Transmission Control Protocol）协议工作的层次，另外还有 UDP（User Datagram Protocol）</p>
<ul>
<li>TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复</li>
<li>UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方</li>
<li>TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收</li>
</ul>
</li>
<li><p>应用层（application layer）“百花齐放”，有各种面向具体应用的协议，例如 Telnet、SSH、FTP、SMTP 等</p>
</li>
<li><p>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message），但这些名词并没有什么本质的区分，可以统称为数据包</p>
</li>
</ul>
<p><strong>OSI 网络分层模型</strong></p>
<p>OSI 全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）。TCP&#x2F;IP 发明于 1970 年代，当时除了它还有很多其他的网络协议，整个网络世界比较混乱，后来国际标准组织（ISO）设计出了一个新的网络分层模型，想用这个新框架来统一既存的各种网络协议</p>
<pre class="mermaid">graph LR
    L7["L7 Application Layer"]
    L6["L6 Presentation Layer"]
    L5["L5 Session Layer"]
    L4["L4 Transport Layer"]
    L3["L3 Network Layer"]
    L2["L2 Data Link Layer"]
    L1["L1 Physical Layer"]</pre>



<ol>
<li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</li>
<li>第二层：数据链路层，它基本相当于 TCP&#x2F;IP 的 <strong>链接层</strong>；</li>
<li>第三层：网络层，相当于 TCP&#x2F;IP 里的 <strong>网际层</strong>；</li>
<li>第四层：传输层，相当于 TCP&#x2F;IP 里的 <strong>传输层</strong>；</li>
<li>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</li>
<li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li>
<li>第七层：应用层，面向具体的应用传输数据。</li>
</ol>
<blockquote>
<p>OSI 分层模型在发布的时候就明确地表明是一个“参考”，不是强制标准</p>
</blockquote>
<p>TCP&#x2F;IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置。而 OSI 则补足了这个缺失，在理论层面上描述网络更加完整，OSI 的分层模型在四层以上分的太细，而 TCP&#x2F;IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开</p>
<ul>
<li><p>“四层负载均衡”：工作在传输层上，基于 TCP&#x2F;IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡</p>
</li>
<li><p>“七层负载均衡”：工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器</p>
</li>
</ul>
<p>凡是由操作系统负责处理的就是四层或四层以下，凡是需要由应用程序（也就是自己写代码）负责处理的就是七层</p>
<h3 id="HTTP-是什么"><a href="#HTTP-是什么" class="headerlink" title="HTTP 是什么"></a>HTTP 是什么</h3><p><strong>HTTP 协议的发展过程</strong></p>
<ol>
<li>HTTP 协议始于三十年前蒂姆·伯纳斯 - 李的一篇论文（1989 年）；</li>
<li>HTTP&#x2F;0.9 是个简单的文本协议，只能获取文本资源；</li>
<li>HTTP&#x2F;1.0 确立了大部分现在使用的技术，但它不是正式标准（1993 年）；</li>
<li>HTTP&#x2F;1.1 是目前互联网上使用最广泛的协议，功能也非常完善（1999 年）；</li>
<li>HTTP&#x2F;2 基于 Google 的 SPDY 协议，注重性能改善，但还未普及（2015 年）；</li>
<li>HTTP&#x2F;3 基于 Google 的 QUIC 协议，是将来的发展方向（2018 年）。</li>
</ol>
<pre class="mermaid">graph LR
    subgraph 协议
        subgraph 传输
            超文本
        end
    end</pre>

<p><strong>Hypertext Transfer Protocol 超文本传输协议</strong></p>
<ul>
<li>协议<ul>
<li>协议必须要有两个或多个参与者，也就是“协”</li>
<li>协议是对参与者的一种行为约定和规范，也就是“议”</li>
</ul>
</li>
<li>传输<ul>
<li>HTTP 协议是一个“双向协议”，但允许中间有“中转”或者“接力”</li>
</ul>
</li>
<li>超文本<ul>
<li>文字、图片、音频和视频等的混合体，含有“超链接”</li>
</ul>
</li>
</ul>
<p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</p>
<p>在互联网上 HTTP 传输最多的可能就是 HTML（HyperText Markup Language），但要是论数据量，HTML 可能要往后排了，图片、音频、视频这些类型的资源显然更大。</p>
<p>HTTP 通常跑在 TCP&#x2F;IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL&#x2F;TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。</p>
<h3 id="HTTP-相关概念"><a href="#HTTP-相关概念" class="headerlink" title="HTTP 相关概念"></a>HTTP 相关概念</h3><ul>
<li><p><strong>Web 浏览器</strong></p>
<ul>
<li>Web Browser 是检索、查看互联网上网页资源的应用程序，Web 指的是“World Wide Web”（万维网）</li>
<li>浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源</li>
<li>HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理 “，通常都简单地称之为“客户端”</li>
</ul>
</li>
<li><p><strong>Web 服务器</strong></p>
<ul>
<li>硬件含义：物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群</li>
<li>软件含义： 提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上，利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态信息</li>
</ul>
</li>
<li><p><strong>CDN</strong></p>
<ul>
<li>内容分发网络（Content Delivery Network）应用 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求</li>
<li>CDN 一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能</li>
</ul>
</li>
<li><p><strong>爬虫</strong></p>
<ul>
<li>“爬虫”（Crawler）是一种可以自动访问 Web 资源的应用程序</li>
<li>爬虫绝大多数是各大搜索引擎抓取网页存入庞大的数据库，再建立关键字索引</li>
</ul>
</li>
<li><p><strong>HTML&#x2F;WebService&#x2F;WAF</strong></p>
<ul>
<li>HTML 描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面</li>
<li>广义上的 HTML 通常是指 HTML、JavaScript、CSS 等前端技术的组合，能够实现比传统静态页面更丰富的动态页面</li>
<li>Web Service 是一个基于 Web（HTTP）的服务架构技术，具有跨平台跨语言的优点</li>
<li>WAF（Web Application Firewall） 是专门检测 HTTP 流量，是防护 Web 应用的安全技术，通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击</li>
</ul>
</li>
<li><p><strong>TCP&#x2F;IP</strong></p>
<ul>
<li>TCP&#x2F;IP 协议是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈</li>
<li>IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包</li>
<li>TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础<ul>
<li>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节</li>
</ul>
</li>
<li>HTTP 协议就运行在了 TCP&#x2F;IP 上，HTTP 也就可以更准确地称为“HTTP over TCP&#x2F;IP”</li>
</ul>
</li>
<li><p><strong>DNS</strong></p>
<ul>
<li>“域名系统”（Domain Name System）用有意义的名字来作为 IP 地址的等价替代</li>
<li>“域名”（Domain Name）被设计成了一个有层次的结构<ul>
<li>用 “.” 分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低</li>
<li>最左边的是主机名，可以用来表明主机的用途，比如“www”表示提供万维网服务、“mail”表示提供邮件服务</li>
<li>在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务</li>
<li>域名本质上还是个名字空间系统</li>
</ul>
</li>
<li>就像 IP 地址必须转换成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是“域名解析”</li>
<li>域名的其他用途<ul>
<li>重定向：当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器</li>
<li>内部使用：域名是一个名字空间，可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器</li>
<li>负载均衡：域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>URI&#x2F;URL</strong></p>
<ul>
<li>使用 URI（Uniform Resource Identifier），统一资源标识符能够唯一地标记互联网上资源</li>
<li>URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符（俗称的“网址”）</li>
<li>URI 不完全等同于网址，它包含有 URL 和 URN（Uniform Resource Name） 两个部分，因为 URL 太普及，常常把这两者简单地视为相等</li>
<li>客户端看到的必须是完整的 URI，使用特定的协议去连接特定的主机，而服务器看到的只是报文请求行里被删除了协议名和主机名的 URI</li>
</ul>
<pre class="mermaid">  sequenceDiagram
    participant Client as 客户端
    participant Server as 服务器

    Client->>+Server: 请求 (scheme://host:port/path?query)
    activate Server
    Server-->>-Client: 响应
    deactivate Server</pre>
</li>
<li><p><strong>HTTPS</strong></p>
<ul>
<li>HTTPS 全称是“HTTP over SSL&#x2F;TLS”，SSL&#x2F;TLS 它是一个负责加密通信的安全协议，建立在 TCP&#x2F;IP 之上</li>
<li>SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS 即 “Transport Layer Security”</li>
<li>但由于历史的原因还是有很多人称之为 SSL&#x2F;TLS，或者直接简称为 SSL，SSL 综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道</li>
</ul>
</li>
<li><p><strong>代理</strong></p>
<ul>
<li>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答</li>
<li>代理有很多的种类，常见的有：<ol>
<li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li>
<li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</li>
<li>正向代理：靠近客户端，<strong>代表客户端</strong> 向服务器发送请求；</li>
<li>反向代理：靠近服务器端，<strong>代表服务器</strong> 响应客户端的请求；</li>
</ol>
</li>
<li>CDN 实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色</li>
<li>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如：<ol>
<li>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</li>
<li>内容缓存：暂存上下行的数据，减轻后端的压力；</li>
<li>安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</li>
<li>数据处理：提供压缩、加密等额外的功能</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><p><strong>HTTP 报文</strong></p>
<p>HTTP 协议是一个“纯文本”的协议，可读性好，其请求报文和响应报文的结构基本相同，由三大部分组成：</p>
<ol>
<li>起始行（start line）：描述请求或响应的基本信息；</li>
<li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li>
<li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>
</ol>
<p>前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”</p>
<p><strong>请求行</strong></p>
<p>请求行（request line），它简要地描述了客户端想要如何操作服务器端的资源，由三部分构成：</p>
<ol>
<li>请求方法：是一个动词，如 GET&#x2F;POST，表示对资源的操作；</li>
<li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li>
<li>版本号：表示报文使用的 HTTP 协议版本。</li>
</ol>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>

<p><strong>状态行</strong></p>
<p>响应报文里的起始行不叫“响应行”，而是叫“状态行”（status line），意思是服务器响应的状态，同样也是由三部分构成：</p>
<ol>
<li>版本号：表示报文使用的 HTTP 协议版本；</li>
<li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>
<li>原因：是状态码的简短文字描述，但它只是为了兼容早期的文本客户端而存在，目前的大多数客户端都会忽略它。</li>
</ol>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line">HTTP/1.1 404 Not Found</span><br></pre></td></tr></table></figure>

<p><strong>头部字段</strong></p>
<p>请求行或状态行再加上头部字段集合就构成了 HTTP 报文里完整的请求头或响应头，头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。</p>
<p>HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，用头字段需要注意下面几点：</p>
<ol>
<li>字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”、“test_name”是不正确的字段名；</li>
<li>字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；</li>
<li>字段的顺序是没有意义的，可以任意排列不影响语义；</li>
<li>字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。</li>
</ol>
<p><strong>常用头字段</strong></p>
<p>HTTP 协议规定了非常多的头部字段，基本上可以分为四大类：</p>
<ol>
<li>通用字段：在请求头和响应头里都可以出现；</li>
<li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>
<li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
<li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>
</ol>
<p>常见字段：</p>
<ul>
<li>Host 字段，它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP&#x2F;1.1 规范里要求必须出现的字段，Host 字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用 Host 字段来选择，有点像是一个简单的“路由重定向”</li>
<li>User-Agent 是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。</li>
<li>Date 字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。</li>
<li>Server 字段是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号，Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界。</li>
<li>Content-Length 是实体字段，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度</li>
</ul>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>请求方法的实际含义就是客户端发出了一个“动作指令”，要求服务器端对 URI 定位的资源执行这个动作，目前 HTTP&#x2F;1.1 规定了八种方法，单词都必须是大写的形式：<code>GET</code>、<code>HEAD</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>CONNECT</code>、<code>OPTIONS</code>、<code>TRACE</code></p>
<p><strong>GET&#x2F;HEAD</strong></p>
<p>GET 方法的含义是请求从服务器获取资源，这个资源既可以是静态的文本、页面、图片、视频，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据</p>
<p>HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”，比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了，没有必要用 GET 把整个文件都取下来</p>
<p><strong>POST&#x2F;PUT</strong></p>
<p>GET 和 HEAD 方法是从服务器获取数据，而 POST 和 PUT 方法则是相反操作，向 URI 指定的资源提交数据，数据就放在报文的 body 里，通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义</p>
<p>在实际应用中，PUT 用到的比较少，它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据</p>
<p><strong>其他方法</strong></p>
<ul>
<li>DELETE 方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记</li>
<li>CONNECT 是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色</li>
<li>OPTIONS 方法要求服务器列出可对资源实行的操作方法，在响应头的 Allow 字段里返回，它的功能很有限，用处也不大，有的服务器（例如 Nginx）干脆就没有实现对它的支持</li>
<li>TRACE 方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用</li>
</ul>
<h3 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h3><p>RFC 标准把状态码分成了五类：</p>
<ul>
<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；<ul>
<li>偶尔能够见到的是“<strong>101 Switching Protocols</strong>”，它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了</li>
</ul>
</li>
<li>2××：成功，报文已经收到并被正确处理；<ul>
<li>“<strong>200 OK</strong>”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。</li>
<li>“<strong>204 No Content</strong>”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</li>
<li>“<strong>206 Partial Content</strong>”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。</li>
<li>状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99&#x2F;2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节</li>
</ul>
</li>
<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；<ul>
<li>“<strong>301 Moved Permanently</strong>”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。</li>
<li>与它类似的是“<strong>302 Found</strong>”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。<ul>
<li>301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI</li>
</ul>
</li>
<li>“<strong>304 Not Modified</strong>” 用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）</li>
</ul>
</li>
<li>4××：客户端错误，请求报文有误，服务器无法处理；<ul>
<li>“<strong>400 Bad Request</strong>”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误</li>
<li>“<strong>403 Forbidden</strong>”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因</li>
<li>“<strong>404 Not Found</strong>”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端，但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404</li>
<li>开发中常用的还有：<ul>
<li>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</li>
<li>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</li>
<li>408 Request Timeout：请求超时，服务器等待了过长的时间；</li>
<li>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</li>
<li>413 Request Entity Too Large：请求报文里的 body 太大；</li>
<li>414 Request-URI Too Long：请求行里的 URI 太大；</li>
<li>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</li>
<li>431 Request Header Fields Too Large：请求头某个字段或总体太大；</li>
</ul>
</li>
</ul>
</li>
<li>5××：服务器错误，服务器在处理请求时内部发生了错误。<ul>
<li>“<strong>500 Internal Server Error</strong>”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析</li>
<li>“<strong>501 Not Implemented</strong>”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。</li>
<li>“<strong>502 Bad Gateway</strong>”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</li>
<li>“<strong>503 Service Unavailable</strong>”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。<ul>
<li>503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HTTP-的特点"><a href="#HTTP-的特点" class="headerlink" title="HTTP 的特点"></a>HTTP 的特点</h3><p><strong>特点</strong></p>
<ul>
<li><strong>灵活可扩展</strong>：HTTP 协议只规定了报文的基本格式，比如用空格分隔单词，用换行分隔字段，“header+body”等，各个组成部分都没有做严格的语法语义限制</li>
<li><strong>可靠传输</strong>：HTTP 协议是基于 TCP&#x2F;IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据，“可靠”只是向使用者提供了一个“承诺”，会在下层用多种手段“尽量”保证数据的完整送达</li>
<li><strong>应用层协议</strong>：FTP 用于传输文件、SMTP 用于发送邮件、SSH 用于远程登录；HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议</li>
<li><strong>请求-应答：</strong> HTTP 的请求-应答模式恰好契合了传统的 C&#x2F;S（Client&#x2F;Server）系统架构，也完全符合 RPC（Remote Procedure Call）的工作模式，可以把 HTTP 请求处理封装成远程函数调用，导致了 WebService、RESTful 和 gPRC 等的出现</li>
<li><strong>无状态：</strong>“状态”其实就是客户端或者服务器里保存的一些数据或者标志，记录了通信过程中的一些变化信息，HTTP 可以通过“补丁”增加这个特性</li>
</ul>
<p><strong>优点&#x2F;缺点</strong></p>
<ul>
<li>HTTP 最大的优点是简单、灵活和易于扩展；</li>
<li>HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；</li>
<li>HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 等技术来实现“有状态”；</li>
<li>HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；</li>
<li>HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；</li>
<li>HTTP 1.1 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间（HTTP&#x2F;2 和 HTTP&#x2F;3）。</li>
</ul>
<h3 id="HTTP-的实体数据"><a href="#HTTP-的实体数据" class="headerlink" title="HTTP 的实体数据"></a>HTTP 的实体数据</h3><p>HTTP 协议作为应用层的协议，数据到达之后工作只能说是完成了一半，还必须要告诉上层应用这是什么数据才行，早在 HTTP 协议诞生之前，在电子邮件系统里让电子邮件可以发送 ASCII 码以外的任意数据，方案的名字叫做“多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions），简称为 MIME</p>
<p>MIME 是一个很大的标准规范，HTTP 取了其中的一部分，用来标记 body 的数据类型（MIME type），MIME 把数据分成了八大类，每个大类下再细分出多个子类，形式是“type&#x2F;subtype”的字符串，所以能够很容易地纳入 HTTP 头字段里</p>
<p>HTTP 里经常遇到的几个类别：</p>
<ol>
<li>text：即文本格式的可读数据，如超文本文档 text&#x2F;html ，纯文本 text&#x2F;plain、样式表 text&#x2F;css 等</li>
<li>image：即图像文件，有 image&#x2F;gif、image&#x2F;jpeg、image&#x2F;png 等</li>
<li>audio&#x2F;video：音频和视频数据，例如 audio&#x2F;mpeg、video&#x2F;mp4 等</li>
<li>application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释，常见的有 application&#x2F;json，application&#x2F;javascript、application&#x2F;pdf  和 application&#x2F;octet-stream 二进制数据等</li>
</ol>
<p>HTTP 在传输时为了节约带宽，有时候还会压缩数据，还需要有一个“Encoding type”，告诉数据是用的什么编码格式，这样对方才能正确解压缩，还原出原始的数据，常用的 Encoding type 只有下面三种：</p>
<ol>
<li>gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；</li>
<li>deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip</li>
<li>br：一种专门为 HTTP 优化的新压缩算法（Brotli）</li>
</ol>
<p>有了 MIME type 和 Encoding type，无论是浏览器还是服务器就都可以轻松识别出 body 的类型，也就能够正确处理数据了</p>
<p>Accept 字段标记的是客户端可理解的 MIME type，可以用“,”做分隔符列出多个类型，服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 客户端</span><br><span class="line">Accept: text/html,application/xml,image/webp,image/png</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line"># 服务器</span><br><span class="line">Content-Type: text/html</span><br><span class="line"># 如果响应报文里没有 Content-Encoding 字段，就表示响应数据没有被压缩</span><br></pre></td></tr></table></figure>

<p>此外还有语言类型使用的头字段、内容协商的质量值等字段</p>
<pre class="mermaid">graph LR
A[Accept] --> B(Content-Type)
C[Acept-Encoding] --> D(Content-Encoding)
E[Acept-Language] --> F(Content-Language)
G[Acept-Charset] --> B</pre>

<h2 id="HTTP-的应用"><a href="#HTTP-的应用" class="headerlink" title="HTTP 的应用"></a>HTTP 的应用</h2><h3 id="传输大文件"><a href="#传输大文件" class="headerlink" title="传输大文件"></a>传输大文件</h3><ul>
<li><p><strong>数据压缩</strong>：gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理效果不好</p>
</li>
<li><p><strong>分块传输</strong></p>
<ul>
<li>“化整为零”的思路在 HTTP 协议里就是“chunked”分块传输编码，在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送</li>
<li>“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）</li>
</ul>
</li>
<li><p><strong>范围请求&#x2F;多段数据</strong></p>
<ul>
<li>HTTP 协议为了满足这样的需求，提出了“范围请求”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”</li>
<li>不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：<ul>
<li>先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；</li>
<li>开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；</li>
<li>下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这些方法不是互斥的，而是可以混合起来使用，例如压缩后再分块传输，或者分段后再分块</p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p><strong>短连接和长连接</strong></p>
<p>HTTP 协议最初（0.9⁄1.0）是个非常简单的协议，通信过程也采用了简单的“请求 - 应答”方式，它底层的数据传输基于 TCP&#x2F;IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为“<strong>短连接</strong>”（short-lived connections）。早期的 HTTP 协议也被称为是“<strong>无连接</strong>”的协议。</p>
<ul>
<li>HTTP 协议就提出了“<strong>长连接</strong>”的通信方式，也叫“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）</li>
<li>用的就是“<strong>成本均摊</strong>”的思路，既然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本由原来的一个“请求 - 应答”均摊到多个“请求 - 应答”上</li>
</ul>
<p><strong>连接相关的头字段</strong></p>
<p>由于长连接对性能的改善效果非常显著，所以在 HTTP&#x2F;1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段指定，只要向服务器发送了第一次请求，后续的请求都会重复利用第一次打开的 TCP 连接，也就是长连接。</p>
<ul>
<li>在请求头里明确地要求使用长连接机制，使用的字段是 <strong>Connection</strong>，值是“<strong>keep-alive</strong>”</li>
<li>如果服务器支持长连接，它总会在响应报文里放一个“<strong>Connection: keep-alive</strong>”字段</li>
</ul>
<p>因为 TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务。</p>
<ul>
<li><p>客户端可以在请求头里加上“<strong>Connection: close</strong>”字段，告诉服务器：“这次通信后就关闭连接”。</p>
</li>
<li><p>服务器端通常不会主动关闭连接，但也可以使用一些策略。拿 Nginx 来举例，它有两种方式：</p>
<ol>
<li><p>使用“keepalive_timeout”指令，设置长连接的超时时间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。</p>
</li>
<li><p>使用“keepalive_requests”指令，设置长连接上可发送的最大请求次数。比如设置成 1000，那么当 Nginx 在这个连接上处理了 1000 个请求后，也会主动断开连接。</p>
</li>
</ol>
</li>
</ul>
<p><strong>队头阻塞</strong></p>
<p>“队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。因为“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP&#x2F;1.1 里无法解决，只能缓解。</p>
<ul>
<li><p>“<strong>并发连接</strong>”（concurrent connections），是同时对一个域名发起多个长连接，用数量来解决质量的问题</p>
</li>
<li><p>“<strong>域名分片</strong>”（domain sharding）技术还是用数量来解决质量的思路，多开几个域名都指向同一台服务器这样实际长连接的数量就又上去了</p>
</li>
</ul>
<h3 id="重定向和跳转"><a href="#重定向和跳转" class="headerlink" title="重定向和跳转"></a>重定向和跳转</h3><p>“<strong>Location</strong>”字段属于响应字段，必须出现在响应报文里。但只有配合 301⁄302 状态码才有意义，它 <strong>标记了服务器要求重定向的 URI</strong></p>
<ul>
<li><strong>301</strong> 俗称“永久重定向”（Moved Permanently），意思是原 URI 已经“永久”性地不存在了，今后的所有请求都必须改用新的 URI。<ul>
<li>浏览器看到 301，就知道原来的 URI“过时”了，就会做适当的优化。比如历史记录、更新书签，下次可能就会直接用新的 URI 访问，省去了再次跳转的成本。搜索引擎的爬虫看到 301，也会更新索引库，不再使用老的 URI。</li>
</ul>
</li>
<li><strong>302</strong> 俗称“临时重定向”（“Moved Temporarily”），意思是原 URI 处于“临时维护”状态，新的 URI 是起“顶包”作用的“临时工”。<ul>
<li>浏览器或者爬虫看到 302，会认为原来的 URI 仍然有效，但暂时不可用，所以只会执行简单的跳转页面，不记录新的 URI，也不会有其他的多余动作，下次访问还是用原 URI。</li>
</ul>
</li>
</ul>
<p><strong>重定向的应用场景</strong></p>
<ul>
<li>资源不可用时用另一个新的 URI 来代替</li>
<li>避免重复，让多个网址都跳转到一个 URI，增加访问入口的同时还不会增加额外的工作量</li>
</ul>
<p><strong>重定向的相关问题</strong></p>
<ul>
<li>性能损耗，定向的机制决定了一个跳转会有两次请求 - 应答，比正常的访问多了一次，站内重定向可以长连接复用，站外重定向就要开两个连接</li>
<li>循环跳转，HTTP 协议特别规定，浏览器必须具有检测“循环跳转”的能力，在发现这种情况时应当停止发送请求并给出错误提示</li>
</ul>
<h3 id="Cookie-机制"><a href="#Cookie-机制" class="headerlink" title="Cookie 机制"></a>Cookie 机制</h3><p>Cookie 机制需要用到响应头字段 Set-Cookie 和请求头字段 Cookie：</p>
<ul>
<li>服务器有时会在响应头里添加多个 Set-Cookie，存储多个“key &#x3D; value”</li>
<li>浏览器这边发送时不需要用多个 Cookie 字段，只要在一行里用“;”隔开就行</li>
<li>Cookie 是由浏览器负责存储的，而不是操作系统</li>
</ul>
<p>Cookie 的有效期可以使用 Expires 和 Max-Age 两个属性来设置：</p>
<ul>
<li>“Expires”俗称“过期时间”，用的是绝对时间点，可以理解为“截止日期”（deadline）</li>
<li>“Max-Age”用的是相对时间，单位是秒，浏览器用收到报文的时间点再加上 Max-Age，就可以得到失效的绝对时间</li>
</ul>
<p>设置 Cookie 的作用域，让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用：</p>
<ul>
<li>“Domain”和“Path”指定了 Cookie 所属的域名和路径</li>
<li>浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie，现实中为了省事，通常 Path 就用一个“&#x2F;”或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器自己去挑</li>
</ul>
<p>Cookie 的安全性：</p>
<ul>
<li>属性“HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API</li>
<li>属性“SameSite”可以防范“跨站请求伪造”（XSRF）攻击，设置成“SameSite &#x3D; Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送，而“SameSite &#x3D; Lax”则略宽松一点，允许 GET&#x2F;HEAD 等安全方法，但禁止 POST 跨站发送</li>
<li>“Secure”属性表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送，但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在</li>
</ul>
<p>Cookie 的应用有身份识别、广告跟踪等，为了防止滥用 Cookie 搜集用户隐私，互联网组织相继提出了 DNT（Do Not Track）和 P3P（Platform for Privacy Preferences Project），但实际作用不大</p>
<p>因为 Cookie 并不属于 HTTP 标准（RFC6265，而不是 RFC2616&#x2F;7230），所以语法上与其他字段不太一致，使用的分隔符是“;”，与 Accept 等字段的“,”不同</p>
<h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h3><p><strong>服务器的缓存控制</strong></p>
<p>服务器标记资源有效期使用的头字段是“Cache-Control”，里面的值“max-age &#x3D; 30”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就算是过期，不能用。”</p>
<p>“max-age”是 HTTP 缓存控制最常用的属性，此外在响应报文里还可以用其他的属性来更精确地指示浏览器应该如何使用缓存：</p>
<ul>
<li>no_store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；</li>
<li>no_cache：它的字面含义容易与 no_store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；</li>
<li>must-revalidate：又是一个和 no_cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。</li>
</ul>
<p><strong>客户端的缓存控制</strong></p>
<p>客户端也可以发“Cache-Control”，请求 - 应答的双方都可以用这个字段进行缓存控制，互相协商缓存的使用策略</p>
<ul>
<li>当点“刷新”按钮的时候，浏览器会在请求头里加一个“Cache-Control: max-age &#x3D; 0”，服务器看到 max-age &#x3D; 0，也就会用一个最新生成的报文回应浏览器</li>
<li>Ctrl+F5 的“强制刷新”是发了一个“Cache-Control: no-cache”，含义和“max-age &#x3D; 0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的</li>
<li>在“前进”“后退”“跳转”这些重定向动作中浏览器不会“夹带私货”，只用最基本的请求头，没有“Cache-Control”，所以就会检查缓存，直接利用之前的资源，不再进行网络通信</li>
</ul>
<p><strong>条件请求</strong></p>
<p>条件请求一共有 5 个头字段，最常用的是“if-Modified-Since”和“If-None-Match”这两个</p>
<ul>
<li>需要第一次的响应报文预先提供“Last-modified”和“ETag”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的</li>
<li>如果资源没有变，服务器就回应一个“304 Not Modified”，表示缓存依然有效，浏览器就可以更新一下有效期</li>
</ul>
<p>ETag 是“实体标签”（Entity Tag）的缩写，<strong>是资源的一个唯一标识</strong>，主要是用来解决修改时间无法准确区分文件变化的问题：</p>
<ul>
<li>一个文件在一秒内修改了多次，但因为修改时间是秒级，所以这一秒内的新版本无法区分。</li>
<li>一个文件定期更新，但有时会是同样的内容，实际上没有变化，用修改时间就会误以为发生了变化，传送给浏览器就会浪费带宽。</li>
</ul>
<h3 id="代理服务"><a href="#代理服务" class="headerlink" title="代理服务"></a>代理服务</h3><pre class="mermaid">graph LR
A[浏览器] -- "请求" --> B(代理服务器)
B -- "请求" --> C(源服务器)
C -- "响应" --> B
B -- "响应" --> A</pre>

<p><strong>代理的作用</strong></p>
<p>“计算机科学领域里的任何问题，都可以通过引入一个中间层来解决”（在这句话后面还可以再加上一句“如果一个中间层解决不了问题，那就再加一个中间层”）</p>
<p>代理最基本的一个功能是负载均衡，在负载均衡的同时，代理服务还可以执行更多的功能，比如：</p>
<ul>
<li><strong>健康检查</strong>：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用；</li>
<li><strong>安全防护</strong>：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载；</li>
<li><strong>加密卸载</strong>：对外网使用 SSL&#x2F;TLS 加密通信认证，而在安全的内网不加密，消除加解密成本；</li>
<li><strong>数据过滤</strong>：拦截上下行的数据，任意指定策略修改请求或者响应；</li>
<li><strong>内容缓存</strong>：暂存、复用服务器响应。</li>
</ul>
<p><strong>代理相关头字段</strong></p>
<ul>
<li>Via 是一个通用字段，请求头或响应头里都可以出现。每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾，它只解决了客户端和源服务器判断是否存在代理的问题，还不能知道对方的真实信息</li>
<li>服务器的 IP 地址应该是保密的，关系到企业的内网安全，所以一般不会让客户端知道；通常服务器又需要知道客户端的真实 IP 地址，方便做访问控制、用户画像、统计分析</li>
<li>HTTP 标准里并没有为此定义头字段，但已经出现了很多“事实上的标准”，最常用的两个头字段是“X-Forwarded-For”和“X-Real-IP”<ul>
<li>“X-Forwarded-For”的字面意思是“为谁而转发”，形式上和“Via”差不多，Via”追加的是代理主机名（或者域名），而“X-Forwarded-For”追加的是请求方的 IP 地址</li>
<li>“X-Real-IP”是另一种获取客户端真实 IP 的手段，它的作用很简单，就是记录客户端 IP 地址，没有中间的代理信息，相当于是“X-Forwarded-For”的简化版</li>
</ul>
</li>
</ul>
<p><strong>代理协议</strong></p>
<p>因为通过“X-Forwarded-For”操作代理信息必须要解析 HTTP 报文头，这对于代理来说成本比较高，原本只需要简单地转发消息就好，而现在却必须要费力解析数据再修改数据，会降低代理的转发性能。所以就出现了一个专门的“代理协议”（The PROXY protocol），它由知名的代理软件 HAProxy 所定义，也是一个“事实标准”，被广泛采用（注意并不是 RFC）。</p>
<p>“代理协议”v1 是在 HTTP 报文前增加了一行 ASCII 码文本，相当于又多了一个头，这一行文本其实非常简单，开头必须是“PROXY”五个大写字母，然后是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束。</p>
<p>服务器看到这样的报文，只要解析第一行就可以拿到客户端地址，不需要再去理会后面的 HTTP 数据，省了很多事情。</p>
<p>不过代理协议并不支持“X-Forwarded-For”的链式地址形式，所以拿到客户端地址后再如何处理就需要代理服务器与后端自行约定。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：机密性、完整性，身份认证和不可否认：</p>
<ul>
<li><strong>机密性</strong>（Secrecy&#x2F;Confidentiality）是指对数据的“保密”，只能由可信的人访问，对其他人是不可见的“秘密”，简单来说就是不能让不相关的人看到不该看的东西。</li>
<li><strong>完整性</strong>（Integrity，也叫一致性）是指数据在传输过程中没有被 <strong>窜改</strong>，不多也不少，“完完整整”地保持着原状。</li>
<li><strong>身份认证</strong>（Authentication）是指确认对方的真实身份，也就是“证明你真的是你”，保证消息只能发送给可信的人。</li>
<li><strong>不可否认</strong>（Non-repudiation&#x2F;Undeniable），也叫不可抵赖，意思是不能否认已经发生过的行为，不能“说话不算数”“耍赖皮”</li>
</ul>
<p>只有同时具备了机密性、完整性、身份认证、不可否认这四个特性，通信双方的利益才能有保障，才能算得上是真正的安全</p>
<p>HTTPS 名字里的“S”，是把 HTTP 下层的传输协议由 TCP&#x2F;IP 换成了 SSL&#x2F;TLS，由“HTTP over TCP&#x2F;IP”变成了“HTTP over SSL&#x2F;TLS”，让 HTTP 运行在了安全的 SSL&#x2F;TLS 协议上</p>
<h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL&#x2F;TLS"></a>SSL&#x2F;TLS</h3><p>SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。</p>
<p>到今天 TLS 已经发展出了三个版本，分别是 2006 年的 1.1、2008 年的 1.2 和去年 2018 的 1.3，目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1⁄1.0、SSLv3&#x2F;v2）都已经被认为是不安全的，各大浏览器在 2020 年左右停止支持。</p>
<p>浏览器和服务器在使用 TLS 建立连接时需要选择 <strong>一组恰当的加密算法</strong> 来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫 <strong>加密套件</strong>），TLS 的密码套件命名非常规范，基本的形式是“密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法”，如：</p>
<p>“ECDHE-RSA-AES256-GCM-SHA384” - “握手时使用 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数。”</p>
<p>OpenSSL 是一个著名的开源密码学程序库和工具包，几乎支持所有公开的加密算法和协议，已经成为了事实上的标准，许多应用软件都会使用它作为底层库来实现 TLS 功能，包括常用的 Web 服务器 Apache、Nginx 等。</p>
<h3 id="对称与非对称加密"><a href="#对称与非对称加密" class="headerlink" title="对称与非对称加密"></a>对称与非对称加密</h3><p>实现机密性最常用的手段是“<strong>加密</strong>”（encrypt），就是把消息用某种方式转换成谁也看不懂的乱码，只有掌握特殊“钥匙”的人才能再转换出原始文本。</p>
<p>这里的“钥匙”就叫做“<strong>密钥</strong>”（key），加密前的消息叫“<strong>明文</strong>”（plain text&#x2F;clear text），加密后的乱码叫“<strong>密文</strong>”（cipher text），使用密钥还原明文的过程叫“<strong>解密</strong>”（decrypt），是加密的反操作，加密解密的操作过程就是“<strong>加密算法</strong>”。</p>
<p>按照密钥的使用方式，加密可以分为两大类：<strong>对称加密和非对称加密</strong>。</p>
<p><strong>对称加密</strong></p>
<p>“对称加密”就是指加密和解密时使用的密钥都是同一个，是“对称”的，只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。</p>
<p>TLS 里有非常多的对称加密算法可供选择，比如 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法都被认为是不安全的，通常都禁止使用，目前常用的只有 AES 和 ChaCha20。</p>
<ul>
<li><strong>AES</strong> 的意思是“高级加密标准”（Advanced Encryption Standard），密钥长度可以是 128、192 或 256。它是 DES 算法的替代者，安全强度很高，性能也很好，而且有的硬件还会做特殊优化，所以非常流行，是应用最广泛的对称加密算法</li>
<li>ChaCha20 是 Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能要超过 AES，曾经在移动客户端上比较流行，但 ARMv8 之后也加入了 AES 硬件优化，所以现在不再具有明显的优势，但仍然算得上是一个不错算法</li>
</ul>
<p><strong>非对称加密</strong></p>
<p>对称加密看上去好像完美地实现了机密性，但其中有一个很大的问题：如何把密钥安全地传递给对方，术语叫“<strong>密钥交换</strong>”。</p>
<p>非对称加密（也叫公钥加密算法）有两个密钥，一个叫“<strong>公钥</strong>”（public key），一个叫“<strong>私钥</strong>”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。</p>
<p>公钥和私钥有个特别的“<strong>单向</strong>”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。</p>
<p>非对称加密可以解决“密钥交换”的问题。网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。</p>
<p>非对称加密算法的设计要比对称算法难得多，在 TLS 里只有很少的几种，比如 DH、DSA、RSA、ECC 等</p>
<ul>
<li>RSA 可能是其中最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于“<strong>整数分解</strong>”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。</li>
<li>ECC（Elliptic Curve Cryptography）是非对称加密里的“后起之秀”，它基于“<strong>椭圆曲线离散对数</strong>”的数学难题，使用特定的曲线方程和基点生成公钥和私钥，子算法 ECDHE 用于密钥交换，ECDSA 用于数字签名。</li>
</ul>
<p><strong>混合加密</strong></p>
<p>然非对称加密没有“密钥交换”的问题，但因为它们都是基于复杂的数学难题，运算速度很慢，即使是 ECC 也要比 AES 差上好几个数量级。如果仅用非对称加密，虽然保证了安全，但通信速度有如乌龟、蜗牛，实用性就变成了零。</p>
<blockquote>
<p>RSA 的运算速度是非常慢的，2048 位的加解密大约是 15KB&#x2F;S（微秒或毫秒级），而 AES128 则是 13MB&#x2F;S（纳秒级），差了几百倍。</p>
</blockquote>
<p>TLS 里使用的混合加密方式，解决了对称加密算法的密钥交换问题，而且 <strong>安全和性能兼顾</strong>，完美地实现了 <strong>机密性</strong>。</p>
<h3 id="数字签名与证书"><a href="#数字签名与证书" class="headerlink" title="数字签名与证书"></a>数字签名与证书</h3><p>仅有机密性，离安全还差的很远，黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站，另外，黑客也可以伪造身份发布公钥。如果你拿到了假的公钥，混合加密就完全失效了。你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了</p>
<p><strong>摘要算法</strong></p>
<p>实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）</p>
<ul>
<li>可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”</li>
<li>也可以把摘要算法理解成特殊的“单向”加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文</li>
</ul>
<p>MD5（Message-Digest 5）和 SHA-1（Secure Hash Algorithm 1），是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要，但这两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了，目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2</p>
<p>SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要</p>
<p><strong>完整性</strong></p>
<p>摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性</p>
<p>不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性，所以真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了</p>
<p><strong>数字签名</strong></p>
<p>加密算法结合摘要算法，我们的通信过程可以说是比较安全了。但这里还有漏洞，就是通信的两个端点（endpoint）</p>
<p>使用 <strong>非对称加密+摘要算法</strong>，就能够实现“<strong>数字签名</strong>”，同时实现“<strong>身份认证</strong>”和“<strong>不可否认</strong>”</p>
<ul>
<li><strong>签名</strong>：使用私钥对数据（通常是数据的哈希值）进行加密的过程，这个过程产生一个数字签名，该签名是唯一的，并且只能由持有相应公钥的人来解密</li>
<li><strong>验签</strong>：使用与签名私钥对应的公钥来解密签名，并验证其有效性</li>
</ul>
<p><strong>数字证书和 CA</strong></p>
<p><strong>CA</strong>（Certificate Authority，证书认证机构）像网络世界里的公安局、教育部、公证中心，具有极高的可信度，由它来给各个 <strong>公钥</strong> 签名，用自身的信誉来保证公钥无法伪造，是可信的，解决“<strong>公钥的信任</strong>”问题</p>
<p>CA 对公钥的签名认证也是有格式的，不是简单地把公钥绑定在持有者身份上就完事了，还要包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“<strong>数字证书</strong>”（Certificate）</p>
<p>知名的 CA 全世界就那么几家，比如 DigiCert、VeriSign、Entrust、Let’s Encrypt 等，它们签发的证书分 DV、OV、EV 三种，区别在于可信程度。</p>
<p>小一点的 CA 可以让大 CA 签名认证，但链条的最后，也就是 <strong>Root CA</strong>，就只能自己证明自己了，这个就叫“<strong>自签名证书</strong>”（Self-Signed Certificate）或者“<strong>根证书</strong>”（Root Certificate）。你必须相信，否则整个证书信任链就走不下去了</p>
<p>操作系统和浏览器都内置了各大 CA 的根证书，上网的时候只要服务器发过来它的证书，就可以验证证书里的签名，顺着证书链（Certificate Chain）一层层地验证，直到找到根证书，就能够确定证书是可信的，从而里面的公钥也是可信的</p>
<h3 id="TLS-1-2-连接过程"><a href="#TLS-1-2-连接过程" class="headerlink" title="TLS 1.2 连接过程"></a>TLS 1.2 连接过程</h3><p>TLS 包含几个子协议，比较常用的有记录协议、警报协议、握手协议、变更密码规范协议等</p>
<ul>
<li><strong>记录协议</strong>（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK</li>
<li><strong>警报协议</strong>（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接</li>
<li><strong>握手协议</strong>（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN&#x2F;ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统</li>
<li><strong>变更密码规范协议</strong>（Change Cipher Spec Protocol），是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的</li>
</ul>
<p><strong>ECDHE 握手过程</strong></p>
<ol>
<li>在 TCP 建立连接之后，客户端会首先发一个“<strong>Client Hello</strong>”消息，也就是跟服务器“打招呼”。里面有客户端的版本号、支持的密码套件，还有一个 <strong>随机数（Client Random）</strong>，用于后续生成会话密钥。</li>
<li>服务器收到“Client Hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个 <strong>随机数（Server Random）</strong>，然后从客户端的列表里选一个作为本次通信使用的密码套件</li>
<li>服务器为了证明自己的身份，就把 <strong>证书</strong> 也发给了客户端（Server Certificate）</li>
<li>因为服务器选择了 ECDHE 算法，所以它会在证书后发送“<strong>Server Key Exchange</strong>”消息，里面是 <strong>椭圆曲线的公钥（Server Params）</strong>，用来实现密钥交换算法，再加上自己的私钥签名认证</li>
<li>客户端和服务器通过明文共享了三个信息：<strong>Client Random、Server Random 和 Server Params</strong></li>
<li>客户端按照密码套件的要求，也生成一个 <strong>椭圆曲线的公钥（Client Params）</strong>，用“<strong>Client Key Exchange</strong>”消息发给服务器</li>
<li>客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），就用 ECDHE 算法一阵算，算出了一个新的东西，叫“<strong>Pre-Master</strong>”，其实也是一个随机数</li>
<li>现在客户端和服务器手里有了三个随机数：<strong>Client Random、Server Random 和 Pre-Master</strong>。用这三个作为原始材料，就可以生成用于加密会 话的主密钥，叫“<strong>Master Secret</strong>”。而黑客因为拿不到“Pre-Master”，所以也就得不到主密钥</li>
<li>有了主密钥和派生的会话密钥，握手就快结束了。客户端发一个“<strong>Change Cipher Spec</strong>”，然后再发一个“<strong>Finished</strong>”消息，把之前所有发送的数据做个摘要，再加密一下，让服务器做个验证</li>
<li>服务器也是同样的操作，发“<strong>Change Cipher Spec</strong>”和“<strong>Finished</strong>”消息，双方都验证加密解密 OK，握手正式结束，后面就收发被加密的 HTTP 请求和响应了</li>
</ol>
<p><strong>双向认证</strong></p>
<p>上面说的是“<strong>单向认证</strong>”握手过程，只认证了服务器的身份，而没有认证客户端的身份。这是因为通常单向认证通过后已经建立了安全通信，用账号、密码等简单的手段就能够确认用户的真实身份。</p>
<p>但为了防止账号、密码被盗，有的时候（比如网上银行）还会使用 U 盾给用户颁发客户端证书，实现“<strong>双向认证</strong>”，这样会更加安全。</p>
<p>双向认证的流程也没有太多变化，只是在“<strong>Server Hello Done</strong>”之后，“<strong>Client Key Exchange</strong>”之前，客户端要发送“<strong>Client Certificate</strong>”消息，服务器收到后也把证书链走一遍，验证客户端的身份。</p>
<h3 id="TLS-1-3-特性解析"><a href="#TLS-1-3-特性解析" class="headerlink" title="TLS 1.3 特性解析"></a>TLS 1.3 特性解析</h3><p> TLS1.3 的三个主要改进目标：兼容、安全与性能</p>
<ul>
<li>最大化兼容性</li>
<li>强化安全</li>
<li>提升性能</li>
</ul>
<h2 id="Other-Points"><a href="#Other-Points" class="headerlink" title="Other Points"></a>Other Points</h2><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h3><p>HTTP 有两个主要的缺点：安全不足和性能不高。</p>
<p>HTTPS，通过引入 SSL&#x2F;TLS 在安全上达到了“极致”，但在性能提升方面却是乏善可陈，只优化了握手加密的环节，对于整体的数据传输没有提出更好的改进方案，还只能依赖于“长连接”这种“落后”的技术。</p>
<p>在 HTTPS 逐渐成熟之后，HTTP 就向着性能方面开始“发力”，走出了另一条进化的道路。</p>
<blockquote>
<p>与 HTTPS 不同，HTTP&#x2F;2 没有在 URI 里引入新的协议名，仍然用“http”表示明文协议，用“https”表示加密协议</p>
</blockquote>
<ul>
<li><strong>兼容 HTTP&#x2F;1</strong></li>
<li><strong>头部压缩</strong></li>
<li><strong>二进制格式</strong></li>
<li><strong>虚拟的“流”</strong></li>
<li><strong>强化安全</strong></li>
<li><strong>协议栈</strong></li>
</ul>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/20240905120540.png" fancybox="true"/></div></div>

<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP 3"></a>HTTP 3</h3><div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/20240905120929.png" fancybox="true"/></div></div>

<h3 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h3><p>Web 服务器就那么几款，目前市面上主流的只有两个：Apache 和 Nginx，两者合计占据了近 90% 的市场份额。Nginx，它是 Web 服务器的“后起之秀”，虽然比 Apache 小了 10 岁，但增长速度十分迅猛。</p>
<blockquote>
<p>Nginx 应该读成“Engine X”，但“X”念起来太“拗口”，倾向于读做“Engine ks”，这也与 UNIX、Linux 的发音一致</p>
</blockquote>
<p><strong>进程池</strong></p>
<p>Nginx 作为“轻量级”的服务器，它的 CPU、内存占用都非常少，同样的资源配置下就能够为更多的用户提供服务，其奥秘在于它独特的工作模式。</p>
<p>在 Nginx 之前，Web 服务器的工作模式大多是“Per-Process”或者“Per-Thread”，对每一个请求使用单独的进程或者线程处理。这就存在创建进程或线程的成本，还会有进程、线程“上下文切换”的额外开销。如果请求数量很多，CPU 就会在多个进程、线程之间切换时“疲于奔命”，平白地浪费了计算时间。</p>
<p>Nginx 使用了“<strong>进程池 + 单线程</strong>”的工作模式，在启动的时候会预先创建好固定数量的 worker 进程，在之后的运行过程中不会再 fork 出新进程，这就是进程池，而且可以自动把进程“绑定”到独立的 CPU 上，这样就完全消除了进程创建和切换的成本，能够充分利用多核 CPU 的计算能力。</p>
<p>在进程池之上，还有一个“master”进程，用来监控进程，自动恢复发生异常的 worker，保持进程池的稳定和服务能力。</p>
<p><strong>I&#x2F;O 多路复用</strong></p>
<p>Nginx 就选择了单线程的方式，带来的好处就是开发简单，没有互斥锁的成本，减少系统消耗。单线程的 Nginx，处理能力却能够超越其他多线程的服务器要归功于 Nginx 利用了 Linux 内核里的一件“神兵利器”，<strong>I&#x2F;O 多路复用接口</strong>，“大名鼎鼎”的 epoll。</p>
<p>Web 服务器从根本上来说是“I&#x2F;O 密集型”而不是“CPU 密集型”，处理能力的关键在于网络收发而不是 CPU 计算（这里暂时不考虑 HTTPS 的加解密），而网络 I&#x2F;O 会因为各式各样的原因不得不等待，比如数据还没到达、对端没有响应、缓冲区满发不出去等等。</p>
<ul>
<li>对于一般的单线程来说 CPU 就会“停下来”，造成浪费</li>
<li>多线程的解决思路有点类似“并发连接”，虽然有的线程可能阻塞，但由于多个线程并行，总体上看阻塞的情况就不会太严重了。</li>
<li>Nginx 里使用的 epoll，就好像是 HTTP&#x2F;2 里的“多路复用”技术，它把多个 HTTP 请求处理打散成碎片，都“复用”到一个单线程里，不按照先来后到的顺序处理，而是只当连接上真正可读、可写的时候才处理，如果可能发生阻塞就立刻切换出去，处理其他的请求。</li>
</ul>
<p>通过这种方式，Nginx 就完全消除了 I&#x2F;O 阻塞，把 CPU 利用得“满满当当”，又因为网络收发并不会消耗太多 CPU 计算能力，也不需要切换进程、线程，所以整体的 CPU 负载是相当低的。</p>
<p>epoll 还有一个特点，大量的连接管理工作都是在操作系统内核里做的，这就减轻了应用程序的负担，所以 Nginx 可以为每个连接只分配很小的内存维护状态，即使有几万、几十万的并发连接也只会消耗几百 M 内存，而其他的 Web 服务器这个时候早就“Memory not enough”了。</p>
<p><strong>多阶段处理</strong></p>
<p>Nginx 在内部也采用的是“<strong>化整为零</strong>”的思路，把整个 Web 服务器分解成了多个“功能模块”，Nginx 的 HTTP 处理有四大类模块：</p>
<ol>
<li>handler 模块：直接处理 HTTP 请求；</li>
<li>filter 模块：不直接处理请求，而是加工过滤响应报文；</li>
<li>upstream 模块：实现反向代理功能，转发请求到其他服务器；</li>
<li>balance 模块：实现反向代理时的负载均衡算法。</li>
</ol>
<p>Nginx 里的 handler 模块和 filter 模块就是按照“职责链”模式设计和组织的，HTTP 请求报文就是“原材料”，各种模块就是工厂里的工人，走完模块构成的“流水线”，出来的就是处理完成的响应报文。</p>
<p> Nginx 的“流水线”，在 Nginx 里的术语叫“阶段式处理”（Phases），一共有 11 个阶段，每个阶段里又有许多各司其职的模块。</p>
<h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>HTTPS 只是网络安全中很小的一部分，仅仅保证了“通信链路安全”，让第三方无法得知传输的内容。在通信链路的两端，也就是客户端和服务器，它是无法提供保护的。</p>
<p><strong>Web 服务遇到的威胁</strong></p>
<ul>
<li>DDoS（distributed denial-of-service attack），耗尽带宽、CPU 和内存，导致网站完全无法提供正常服务</li>
<li>SQL 注入（SQL injection），利用了服务器字符串拼接形成 SQL 语句的漏洞，构造出非正常的 SQL 语句；HTTP 头注入攻击的方式也是类似的原理，服务端程序如果解析不当，就会执行预设的恶意代码</li>
</ul>
<p><strong>网络应用防火墙</strong></p>
<p>传统“防火墙”工作在三层或者四层，隔离了外网和内网，使用预设的规则，只允许某些特定 IP 地址和端口号的数据包通过，拒绝不符合条件的数据流入或流出内网，实质上是一种网络数据过滤设备。</p>
<p>WAF （Web Application Firewall）也是一种“防火墙”，但它工作在七层，看到的不仅是 IP 地址和端口号，还能看到整个 HTTP 报文，所以就能够对报文内容做更深入细致的审核，使用更复杂的条件、规则来过滤数据。</p>
<p>WAF 就是一种“HTTP 入侵检测和防御系统”，通常一款产品能够称为 WAF，要具备下面的一些功能：</p>
<ul>
<li>IP 黑名单和白名单，拒绝黑名单上地址的访问，或者只允许白名单上的用户访问；</li>
<li>URI 黑名单和白名单，与 IP 黑白名单类似，允许或禁止对某些 URI 的访问；</li>
<li>防护 DDoS 攻击，对特定的 IP 地址限连限速；</li>
<li>过滤请求报文，防御“代码注入”攻击；</li>
<li>过滤响应报文，防御敏感信息外泄；</li>
<li>审计日志，记录所有检测到的入侵操作。</li>
</ul>
<p>WAF 就像是平时编写程序时必须要做的函数入口参数检查，拿到 HTTP 请求、响应报文，用字符串处理函数看看有没有关键字、敏感词，或者用正则表达式做一下模式匹配，命中了规则就执行对应的动作，比如返回 403&#x2F;404。</p>
<p>网络安全领域必须时刻记得“<strong>木桶效应</strong>”（也叫“短板效应”），网站的整体安全不在于你加固的最强的那个方向，而是在于你可能都没有意识到的“短板”，使用 WAF 最好“<strong>不要重新发明轮子</strong>”，而是使用现有的、比较成熟的、经过实际考验的 WAF 产品。</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>光速是有限的，虽然每秒 30 万公里，但这只是真空中的上限，在实际的电缆、光缆中的速度会下降到原本的三分之二左右，也就是 20 万公里 &#x2F; 秒，这样一来，地理位置的距离导致的传输延迟就会变得比较明显了。</p>
<p>此外，互联网从逻辑上看是一张大网，但实际上是由许多小网络组成的，网络内部的沟通很顺畅，但网络之间却只有很少的联通点。</p>
<p>还有，网络中还存在许多的路由器、网关，数据每经过一个节点，都要停顿一下，在二层、三层解析转发，这也会消耗一定的时间，带来延迟。把这些因素再放到全球来看，地理距离、运营商网络、路由转发的影响就会成倍增加。</p>
<p><strong>什么是 CDN</strong></p>
<p>CDN 的最核心原则是“<strong>就近访问</strong>”，如果用户能够在本地几十公里的距离之内获取到数据，那么时延就基本上变成 0 了，所以 CDN 投入了大笔资金，在全国、乃至全球的各个大枢纽城市都建立了机房，部署了大量拥有高存储高带宽的节点，构建了一个专用网络。</p>
<p>用户在上网的时候就不直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫“<strong>边缘节点</strong>”（edge node），其实就是缓存了源站内容的代理服务器，这样一来就省去了“长途跋涉”的时间成本，实现了“网络加速”。</p>
<p>在 CDN 领域里，“内容”其实就是 HTTP 协议里的“资源”，比如超文本、图片、视频、应用程序安装包等等。很显然，只有静态资源才能够被缓存加速、就近访问，而动态资源只能由源站实时生成，即使缓存了也没有意义。</p>
<p>不过，如果动态资源指定了“Cache-Control”，允许缓存短暂的时间，那它在这段时间里也就变成了“静态资源”，可以被 CDN 缓存加速。</p>
<p><strong>CDN 的负载均衡</strong></p>
<p>全局负载均衡（Global Sever Load Balance）一般简称为 GSLB，它是 CDN 的“大脑”，主要的职责是当用户接入网络的时候在 CDN 专网中挑选出一个“最佳”节点提供服务，解决的是用户如何找到“最近的”边缘节点，对整个 CDN 网络进行“负载均衡”。</p>
<p>GSLB 最常见的实现方式是“<strong>DNS 负载均衡</strong>”，原来没有 CDN 的时候，权威 DNS 返回的是网站自己服务器的实际 IP 地址，浏览器收到 DNS 解析结果后直连网站。</p>
<p>加入 CDN 后，权威 DNS 返回的不是 IP 地址，而是一个 CNAME( Canonical Name ) 别名记录，指向的就是 CDN 的 GSLB，因为没拿到 IP 地址，于是本地 DNS 就会向 GSLB 再发起请求，这样就进入了 CDN 的全局负载均衡系统，开始“智能调度”，主要的依据有这么几个：</p>
<ol>
<li>看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点；</li>
<li>看用户所在的运营商网络，找相同网络的边缘节点；</li>
<li>检查边缘节点的负载情况，找负载较轻的节点；</li>
<li>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等。</li>
</ol>
<p>GSLB 把这些因素综合起来，用一个复杂的算法，最后找出一台“最合适”的边缘节点，把这个节点的 IP 地址返回给用户，用户就可以“就近”访问 CDN 的缓存代理了。</p>
<p><strong>CDN 的缓存代理</strong></p>
<p>缓存系统是 CDN 的另一个关键组成部分，相当于 CDN 的“心脏”。如果缓存系统的服务能力不够，不能很好地满足用户的需求，那 GSLB 调度算法再优秀也没有用。</p>
<p>两个 CDN 的关键概念：“<strong>命中</strong>”和“<strong>回源</strong>”：</p>
<ul>
<li>“命中”就是指用户访问的资源恰好在缓存系统里，可以直接返回给用户</li>
<li>“回源”则正相反，缓存里没有，必须用代理的方式回源站取。</li>
</ul>
<p>相应地，也就有了两个衡量 CDN 服务质量的指标：“<strong>命中率</strong>”和“<strong>回源率</strong>”，好的 CDN 应该是命中率越高越好，回源率越低越好。现在的商业 CDN 命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上。</p>
<p>怎么样才能尽可能地提高命中率、降低回源率：</p>
<ul>
<li>硬件方面：在存储系统上下功夫，硬件用高速 CPU、大内存、万兆网卡，再搭配 TB 级别的硬盘和快速的 SSD</li>
<li>软件方面：不断“求新求变”，各种新的存储软件，比如 Memcache、Redis、Ceph，尽可能地高效利用存储，存下更多的内容</li>
<li>缓存系统：划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户</li>
<li>高性能的缓存服务：国内的 CDN 厂商内部都是基于开源软件定制，最常用的是专门的缓存代理软件 Squid、Varnish 和 ATS（Apache Traffic Server），Nginx 和 OpenResty 作为 Web 服务器领域的“多面手”，凭借着强大的反向代理能力和模块化、易于扩展的优点，也在 CDN 里占据了不少的份额</li>
</ul>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>TCP Socket 是一种功能接口，通过这些接口就可以使用 TCP&#x2F;IP 协议栈在传输层收发数据，TCP 连接是全双工的。</p>
<p>WebSocket 就是运行在 Web，也就是 HTTP 上的 Socket 通信规范，提供与 TCP Socket 类似的功能，使用它可以像 TCP Socket 一样调用下层协议栈，任意地收发数据。更准确地说，WebSocket 是一种基于 TCP 的轻量级网络通信协议，在地位上是与 HTTP“平级”的。</p>
<p>WebSocket 与 HTTP&#x2F;2 一样，都是为了解决 HTTP 某方面的缺陷而诞生的，HTTP&#x2F;2 针对的是“队头阻塞”，而 WebSocket 针对的是“请求 - 应答”通信模式。</p>
<p>“请求 - 应答”是一种“<strong>半双工</strong>”的通信模式，虽然可以双向收发数据，但同一时刻只能一个方向上有动作，传输效率低。更关键的一点，它是一种“被动”通信模式，服务器只能“被动”响应客户端的请求，无法主动向客户端发送数据。</p>
<blockquote>
<p>HTTP 难以应用在动态页面、即时消息、网络游戏等要求“<strong>实时通信</strong>”的领域</p>
</blockquote>
<p>浏览器是一个“受限的沙盒”，不能用 TCP，只有 HTTP 协议可用，在 WebSocket 出现之前，在浏览器环境里用 JavaScript 开发实时 Web 应用很麻烦，就出现了很多“变通”的技术，“<strong>轮询</strong>”（polling）就是比较常用的的一种。</p>
<p>如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果。轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 CPU 资源，非常不经济。</p>
<p><strong>WebSocket 的特点</strong></p>
<p>WebSocket 是一个真正“<strong>全双工</strong>”的通信协议，与 TCP 一样，客户端和服务器都可以随时向对方发送数据。服务器就可以变得更加“主动”了，一旦后台有新的数据，就可以立即“推送”给客户端，不需要客户端轮询，“实时通信”的效率也就提高了。</p>
<p>WebSocket 采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，但因为它的主要运行环境是浏览器，为了便于推广和应用，在使用习惯上尽量向 HTTP 靠拢，这就是它名字里“Web”的含义。</p>
<p>服务发现方面，WebSocket 没有使用 TCP 的“IP 地址 + 端口号”，而是延用了 HTTP 的 URI 格式，但开头的协议名不是“http”，引入的是两个新的名字：“<strong>ws</strong>”和“<strong>wss</strong>”，分别表示明文和加密的 WebSocket 协议。</p>
<p>WebSocket 的默认端口也选择了 80 和 443，因为现在互联网上的防火墙屏蔽了绝大多数的端口，只对 HTTP 的 80、443 端口“放行”，所以 WebSocket 就可以“伪装”成 HTTP 协议，比较容易地“穿透”防火墙，与服务器建立连接。</p>
<p>虽然大多数情况下会在浏览器里调用 API 来使用 WebSocket，但它不是一个“调用接口的集合”，而是一个通信协议，把它理解成“<strong>TCP over Web</strong>”会更恰当一些。</p>
<p><strong>WebSocket 的帧结构</strong></p>
<p><strong>WebSocket 的握手</strong></p>
<p><strong>总结</strong></p>
<p>浏览器是一个“沙盒”环境，有很多的限制，不允许建立 TCP 连接收发数据，而有了 WebSocket，我们就可以在浏览器里与服务器直接建立“TCP 连接”，获得更多的自由。</p>
<p>不过自由也是有代价的，WebSocket 虽然是在应用层，但使用方式却与“TCP Socket”差不多，过于“原始”，用户必须自己管理连接、缓存、状态，开发上比 HTTP 复杂的多，所以是否要在项目中引入 WebSocket 必须慎重考虑。</p>
<ol>
<li>HTTP 的“请求 - 应答”模式不适合开发“实时通信”应用，效率低，难以实现动态页面，所以出现了 WebSocket；</li>
<li>WebSocket 是一个“全双工”的通信协议，相当于对 TCP 做了一层“薄薄的包装”，让它运行在浏览器环境里；</li>
<li>WebSocket 使用兼容 HTTP 的 URI 来发现服务，但定义了新的协议名“ws”和“wss”，端口号也沿用了 80 和 443；</li>
<li>WebSocket 使用二进制帧，结构比较简单，特殊的地方是有个“掩码”操作，客户端发数据必须掩码，服务器则不用；</li>
<li>WebSocket 利用 HTTP 协议实现连接握手，发送 GET 请求要求“协议升级”，握手过程中有个非常简单的认证机制，目的是防止误连接。</li>
</ol>
<h3 id="HTTP-性能优化"><a href="#HTTP-性能优化" class="headerlink" title="HTTP 性能优化"></a>HTTP 性能优化</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100029001">透视 HTTP 协议</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100007101">趣谈网络协议</a></strong></li>
</ul>


<!-- 
<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div> -->

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/09/23/docker/">容器技术实践与探索 - Docker 🐳</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/08/28/mysql/">MySQL /maɪ ˈsiːkwəl/ 原理与实践 💽</a></div></section></div>








      <!-- 
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@anonymity</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer> -->

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
