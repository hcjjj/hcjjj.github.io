<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 7.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>MySQL /maɪ ˈsiːkwəl/ 原理与实践 💽 - H-sediment</title>

  
    <meta name="description" content="梳理 MySQL 知识体系">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL &#x2F;maɪ ˈsiːkwəl&#x2F; 原理与实践 💽">
<meta property="og:url" content="http://example.com/2024/06/28/mysql/index.html">
<meta property="og:site_name" content="H-sediment">
<meta property="og:description" content="梳理 MySQL 知识体系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/1024px-MySQL.ff87215b43fd7292af172e2a5d9b844217262571.png">
<meta property="article:published_time" content="2024-06-27T16:00:00.000Z">
<meta property="article:modified_time" content="2024-11-27T11:03:51.388Z">
<meta property="article:author" content="hcjjj">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/1024px-MySQL.ff87215b43fd7292af172e2a5d9b844217262571.png">
  
  
  
  <meta name="keywords" content="MySQL">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/icon.png">
  

  

  
    <link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
    <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
    <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"onload="renderMathInElement(document.body);"></script>
  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">H-sediment</div><div class="sub cap">dust in the wind</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/about/">About</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">MySQL /maɪ ˈsiːkwəl/ 原理与实践 💽</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E6%89%A7%E8%A1%8C"><span class="toc-number">1.</span> <span class="toc-text">SQL 执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">2.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log"><span class="toc-number">2.1.</span> <span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog"><span class="toc-number">2.2.</span> <span class="toc-text">binlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">2.3.</span> <span class="toc-text">两阶段提交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">启动方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">隔离的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">4.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">常见索引模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">InnoDB 索引模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95-OR-%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">4.3.</span> <span class="toc-text">唯一索引 OR 普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">4.4.</span> <span class="toc-text">索引的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81-%F0%9F%94%92"><span class="toc-number">5.</span> <span class="toc-text">锁 🔒</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">5.1.</span> <span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">5.2.</span> <span class="toc-text">表级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81"><span class="toc-number">5.3.</span> <span class="toc-text">行锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">5.4.</span> <span class="toc-text">死锁检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E-id"><span class="toc-number">6.</span> <span class="toc-text">自增 id</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></widget>




</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/hcjjj" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg"/></a><a class="social" href="/hcjjj@foxmail.com" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg"/></a><a class="social" href="/H_sediment" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg"/></a><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3845874.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      


  
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@v10/dist/mermaid.min.js"></script>

  <script>
    var mermaid_config = {
      startOnLoad: true,
      theme:
        "auto" == "auto" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "neutral",
      logLevel: 3,
      themeVariables: {
        darkMode: true
      },
      flowchart: {
        useMaxWidth: false,
        htmlLabels: true,
        curve: "linear"
      },
      gantt: {
        axisFormat: "%Y/%m/%d"
      },
      sequence: {
        actorMargin: 50
      }
    }
    if (window.mermaid) {
      mermaid.initialize(mermaid_config);
    }
  </script>




<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/MySQL/">MySQL</a></div><div id="post-meta">发布于&nbsp;<time datetime="2024-06-27T16:00:00.000Z">2024-06-28</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>MySQL /maɪ ˈsiːkwəl/ 原理与实践 💽</span></h1>
<p>梳理 MySQL 知识体系</p>
<span id="more"></span>

<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/1024px-MySQL.ff87215b43fd7292af172e2a5d9b844217262571.png" style="zoom:30%;" />              

<h2 id="SQL-执行"><a href="#SQL-执行" class="headerlink" title="SQL 执行"></a>SQL 执行</h2><pre class="mermaid">graph LR
    客户端-->连接器
    连接器-->查询缓存
    连接器-->分析器
    查询缓存--命中则\n直接返回结果-->客户端
    分析器-->优化器
    优化器-->执行器
    执行器-->存储引擎
    存储引擎</pre>

<ul>
<li><strong>Server 层</strong>：连接器、查询缓存、分析器、优化器、执行器等（包括内置函数、存储过程、触发器、视图等）<ul>
<li>连接器：负责跟客户端建立连接、获取权限、维持和管理连接，客户端如果太长时间没动静，连接器就会自动将它断开</li>
<li><del>查询缓存</del>：key 是查询的语句，value 是查询的结果（查询缓存命中率通常很低），8.0 版本将查询缓存的整块功能删除</li>
<li>分析器：根据词法分析的结果，语法分析器会根据语法规则，判断输入的这个 SQL 语句是否满足 MySQL 语法</li>
<li>优化器：在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序</li>
<li>执行器：开始执行的时候，要先判断一下你对这个表 T 有没有执行的权限，然后使用引擎提供的接口</li>
</ul>
</li>
<li><strong>存储引擎层</strong>：负责数据的存储和提取，插件式支持 <strong>InnoDB</strong>（5.5.5 后默认）、MyISAM、Memory 等存储引擎</li>
</ul>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）。</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>MySQL 中的 <strong>WAL（Write-Ahead Logging）</strong>关键点就是先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB 引擎就会先把记录<strong>写到 redo log 里面，并更新内存</strong>，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<p>InnoDB 的 redo log 是固定大小的文件，从头开始写，写到末尾就又回到开头循环写。有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志），这两种日志有以下三点不同：</p>
<ol>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是 <strong>物理日志</strong>，记录的是“在某个数据页上做了什么修改”；binlog 是 <strong>逻辑日志</strong>，记录的是这个语句的原始逻辑，比如“给 ID &#x3D; 2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是 <strong>循环写</strong> 的，空间固定会用完；binlog 是可以 <strong>追加写</strong> 入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p>执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程：</p>
<pre class="mermaid">graph 
A[取 ID=2 这一行] --> B(数据页在内存中?)
B --> |是| C[返回行数据]
B --> |否| D[磁盘中读入内存]
D --> C
C --> E[将这行的 C 值加 1]
E --> F[写入新行]
F --> G[新行更新到内存]
G --> H[写入 redo log 处于 prepare 阶段]
H --> I[写 binlog]
I --> J[提交事务 redo log 处于 commit 状态]</pre>

<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>为了 <strong>让两份日志之间的逻辑一致</strong>，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。</p>
<p>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
<p>binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式。如果 DBA 承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有 binlog，同时系统会定期做整库备份。</p>
<ul>
<li>redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘，这样可以保证 MySQL 异常重启之后数据不丢失。</li>
<li>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。事务的 <strong>ACID（Atomicity、Consistency、Isolation、Durability）</strong> 即原子性、一致性、隔离性、持久性。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>当数据库上有 <strong>多个事务同时执行</strong> 的时候，就可能出现 <strong>脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）</strong> 的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<p>隔离得越严实，效率就会越低，SQL 标准的事务隔离级别包括<strong>读未提交（read uncommitted）</strong>、<strong>读提交（read committed）</strong>、<strong>可重复读（repeatable read）</strong> 和 <strong>串行化（serializable ）</strong>：</p>
<ul>
<li><strong>读未提交</strong>：一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li><strong>读提交</strong>：一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li><strong>可重复读</strong>：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然，在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li><strong>串行化</strong>：<strong>对于同一行记录</strong>，“写”会加“写锁”，“读”会加“读锁”，当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准：</p>
<ul>
<li><strong>读未提交</strong>：直接返回记录上的最新值，<strong>没有视图概念</strong></li>
<li><strong>读提交</strong>：视图是 <strong>在每个 SQL 语句开始执行的时候</strong> 创建的</li>
<li><strong>可重复读</strong>：视图是 <strong>在事务启动时</strong> 创建的，整个事务存在期间都用这个视图</li>
<li><strong>串行化</strong>：<strong>直接用加锁的方式</strong> 来避免并行访问</li>
</ul>
<blockquote>
<p><strong>什么时候需要“可重复读”的场景呢？</strong></p>
<p>假设管理一个个人银行账户表，一个表存了每个月月底的余额，一个表存了账单明细。这时候要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与 <strong>本月的账单明细</strong> 一致。一定希望 <strong>在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果</strong>。</p>
<p>这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。</p>
</blockquote>
<h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><p>MySQL 的事务启动方式有以下几种：</p>
<ol>
<li>显式启动事务语句， <code>begin</code> 或 <code>start transaction</code>。配套的提交语句是 <code>commit</code>，回滚语句是 <code>rollback</code>。</li>
<li><code>set autocommit=0</code>，这个命令会将这个线程的 <strong>自动提交</strong> 关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你 <strong>主动</strong> 执行 <code>commit</code> 或 <code>rollback</code> 语句，或者断开连接。</li>
</ol>
<h3 id="隔离的实现"><a href="#隔离的实现" class="headerlink" title="隔离的实现"></a>隔离的实现</h3><p>在 MySQL 中，实际上<strong>每条记录在更新的时候都会同时记录一条回滚操作</strong>。记录上的最新值，通过回滚操作，都可以得到前一个状态的值，当没有事务再需要用到这些回滚日志时（就是当系统里没有比这个回滚日志更早的 read-view 的时候），回滚日志会被删除。</p>
<p>假设一个值从 1 被按顺序改成了 2、3、4，不同时刻启动的事务查询这条记录会有不同的 read-view，即<strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong>。</p>
<blockquote>
<p><strong>为什么尽量不要使用长事务？</strong></p>
<p>长事务意味着系统里面会存在很<strong>老的事务视图</strong>。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致 <strong>大量占用存储空间</strong>。除了对回滚段的影响，长事务还 <strong>占用锁资源</strong>，也可能拖垮整个库。</p>
<p><strong>如何避免长事务对业务的影响？</strong></p>
<p>从应用开发端来看：</p>
<ol>
<li>确认是否使用了 set autocommit &#x3D; 0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，<strong>目标就是把它改成 1</strong>。</li>
<li>确认是否有不必要的 <strong>只读事务</strong>。有些框架会习惯不管什么语句先用 begin&#x2F;commit 框起来。有些是业务并没有这个需要，但是也 <strong>把好几个 select 语句放到了事务中</strong>。这种只读事务可以去掉。</li>
<li>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来 <strong>控制每个语句执行的最长时间</strong>，避免单个语句意外执行太长时间。</li>
</ol>
<p>从数据库端来看：</p>
<ol>
<li><strong>监控</strong> information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 &#x2F; 或者 kill；</li>
<li>Percona 的 pt-kill 工具；</li>
<li>在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；</li>
<li>如果使用的是 MySQL 5.6 或者更新版本，<strong>把 innodb_undo_tablespaces 设置成 2（或更大的值）</strong>。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li>
</ol>
</blockquote>
<p><strong>事务到底是隔离的还是不隔离的？</strong></p>
<p><code>begin/start transaction</code> 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果想要马上启动一个事务，可以使用 <code>start transaction with consistent snapshot</code> 这个命令。</p>
<blockquote>
<p>第一种启动方式，一致性视图是在第执行第一个快照读语句时创建的； 第二种启动方式，一致性视图是在执行 <code>start transaction with consistent snapshot</code>时创建的。</p>
</blockquote>
<p>在 MySQL 里，有两个“视图”的概念：</p>
<ul>
<li>一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 <code>create view …</code> ，而它的查询方法与表一样。</li>
<li>另一个是 InnoDB 在实现 MVCC 时用到的<strong>一致性读视图</strong>，即 consistent read view，用于支持 <strong>RC（Read Committed，读提交）</strong>和 <strong>RR（Repeatable Read，可重复读）</strong>隔离级别的实现。</li>
</ul>
<p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p>
<p><strong>“快照”在 MVCC 里是怎么工作的？</strong></p>
<p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是 <strong>基于整库</strong> 的（但并不需要拷贝整库数据）。</p>
<ul>
<li>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 <strong>transaction id</strong>。它是在事务开始的时候向 InnoDB 的事务系统申请的，是<strong>按申请顺序严格递增</strong>的。</li>
<li>而<strong>每行数据也都是有多个版本的</strong>。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 <strong>row trx_id</strong>。</li>
<li>数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</li>
</ul>
<pre class="mermaid">graph LR
    V1["V1 (k=1)<br>row trx-id=10"]
    V2["V2 (k=10)<br>row trx-id=15"]
    V3["V3 (k=11)<br>row trx-id=17"]
    V4["V4 (k=22)<br>row trx-id=25"]

    V1 -->|U1: set k=10<br>transaction id=15| V2
    V2 -->|U2: set k=k+1<br>transaction id=17| V3
    V3 -->|U3: set k=k*2<br>transaction id=25| V4</pre>

<p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，<strong>这个事务执行期间，其他事务的更新对它不可见</strong>。即一个事务以启动的时刻为准，如果一个数据版本是在启动之前生成的就认；如果是启动以后才生成的就不认，如果是这个事务自己更新的数据，还是要认的。</p>
<p>在实现上， <strong>InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。</strong>“活跃”指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</p>
<pre class="mermaid">graph LR
    A["<font color=green>已提交事务</font>"] 
    B["<font color=orange>未提交事务集合</font>"]
    C["<font color=red>未开始事务</font>"]
    D["当前事务"]

    A <-->|低水位| B
    B <-->|高水位| C
    D --> B</pre>

<p>对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p>
<ol>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>
<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>
<li>如果落在黄色部分，那就包括两种情况 <ol>
<li>若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见； </li>
<li>若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
</li>
</ol>
<p><strong>InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p>
<p>一个数据版本，对于一个事务视图来说，除了<strong>自己的更新总是可见</strong>以外，有三种情况：</p>
<ol>
<li>版本未提交，不可见；</li>
<li>版本已提交，但是是在视图<strong>创建后</strong>提交的，不可见；</li>
<li>版本已提交，而且是在视图<strong>创建前</strong>提交的，可见。</li>
</ol>
<p><strong>更新逻辑</strong></p>
<p>当要去更新数据的时候，就不能再在历史版本上更新了，否则其他事务的更新就丢失了，这里就用到了这样一条规则：更新数据都是<strong>先读后写</strong>的，而这个读，只能读当前的值，称为“<strong>当前读</strong>”（current read）。 <strong>除了 update 语句外，select 语句如果加锁，也是当前读</strong>。</p>
<p><code>select * from t where id=1</code> 改为修改一下，加上 <code>lock in share mode</code> 或 <code>for update</code>，下面这两个 select 语句，就是分别加了<strong>读锁（S 锁，共享锁）</strong>和<strong>写锁（X 锁，排他锁）</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select k from t where id=1 lock in share mode;</span><br><span class="line">mysql&gt; select k from t where id=1 for update;</span><br></pre></td></tr></table></figure>

<p>如果事务 C 没有提交，在同一行的写锁还没释放，事务 B 是当前读必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C 释放这个锁，才能继续它的当前读。</p>
<p><strong>可重复读</strong>的核心就是<strong>一致性读（consistent read）</strong>；而事务<strong>更新数据</strong>的时候，只能用<strong>当前读</strong>。如果当前的记录的<strong>行锁</strong>被其他事务占用的话，就需要进入<strong>锁等待</strong>。</p>
<p>而<strong>读提交</strong>的逻辑和<strong>可重复读</strong>的逻辑类似，它们最主要的区别是：</p>
<ul>
<li>在可重复读隔离级别下，只需要在<strong>事务开始的时候</strong>创建一致性视图，之后事务里的其他查询都共用这个<strong>一致性视图</strong>；</li>
<li>在读提交隔离级别下，<strong>每一个语句执行前</strong>都会重新算出一个新的视图。</li>
</ul>
<p>为什么<strong>表结构</strong>不支持“可重复读”？这是因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循<strong>当前读</strong>的逻辑，MySQL 8.0 已经可以把表结构放在 InnoDB 字典里了，也许以后会支持表结构的可重复读。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="常见索引模型"><a href="#常见索引模型" class="headerlink" title="常见索引模型"></a>常见索引模型</h3><p>索引的常见模型有哈希表、有序数组、搜索树：</p>
<ul>
<li><strong>哈希表</strong> 是一种以键 - 值（key-value）存储数据的结构，<strong>拉链法</strong>解决哈希冲突的问题，区间需要全部扫描，哈希表这种结构适用于只有<strong>等值查询</strong>的场景。</li>
<li><strong>有序数组</strong> 在等值查询和范围查询场景中的性能就都非常优秀，但是往中间插入一个记录就必须得挪动后面所有的记录，有序数组索引只适用于<strong>静态数据存储</strong>引擎。</li>
<li><strong>二叉搜索树</strong> 为了维持 O(log(N)) 的查询复杂度，就需要保持这棵树是平衡二叉树，为了做这个保证，更新的时间复杂度也是 O(log(N))。</li>
<li><strong>N 叉树</strong><ul>
<li>树可以有二叉，也可以有多叉，<strong>二叉树是搜索效率最高的</strong>，但是实际上大多数的数据库存储却并不使用二叉树，因为<strong>索引不止存在内存中，还要写到磁盘上</strong></li>
<li>100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块，在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间</li>
<li>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块则使用“N 叉”树，“N”取决于数据块的大小</li>
<li>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了</li>
<li>树根的数据块总是在内存中的（第二层也有很大概率在），一个 <strong>10 亿行</strong>的表上一个整数字段的索引，查找一个值最多只需要访问 2-3 次磁盘</li>
<li>N 叉树由于在<strong>读写上的性能优点</strong>，以及<strong>适配磁盘的访问模式</strong>，已经被广泛应用在数据库引擎中了<blockquote>
<p><strong>在 MySQL 中，索引是在存储引擎层实现的</strong>，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样，而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="InnoDB-索引模型"><a href="#InnoDB-索引模型" class="headerlink" title="InnoDB 索引模型"></a>InnoDB 索引模型</h3><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为<strong>索引组织表</strong>。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p>
<p>根据叶子节点的内容，索引类型分为 <strong>主键索引</strong> 和 <strong>非主键索引</strong>：</p>
<ul>
<li>主键索引的叶子节点存的是整行数据，<strong>主键索引也被称为聚簇索引</strong>（clustered index）</li>
<li>非主键索引的叶子节点内容是主键的值，<strong>非主键索引也被称为二级索引</strong>（secondary index）</li>
</ul>
<blockquote>
<p><strong>基于主键索引和普通索引的查询有什么区别？</strong></p>
<ul>
<li>如果语句是 select * from T where ID &#x3D; 500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li>
<li>如果语句是 select * from T where k &#x3D; 5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li>
</ul>
<p>即基于非主键索引的查询需要多扫描一棵索引树</p>
</blockquote>
<p><strong>索引维护</strong></p>
<p><strong>页分裂</strong>：如果插入数据所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去</p>
<p><strong>页合并</strong>：当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并（分裂过程的逆过程）</p>
<blockquote>
<p><strong>哪些场景下应该使用自增主键，而哪些场景下不应该？</strong></p>
<p>自增主键： NOT NULL PRIMARY KEY AUTO_INCREMENT，每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂，而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。此外，<strong>主键长度越小，二级索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p>
<p>如果业务的场景需求是只有一个索引且该索引必须是唯一索引（典型的 KV 场景），这时候就要优先考虑“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树（避免回表）。</p>
</blockquote>
<p><strong>覆盖索引</strong></p>
<p><code>select * from T where k between 3 and 5</code> 的查找过程（k 上有索引）：</p>
<ol>
<li>在 k 索引树上找到 k &#x3D; 3 的记录，取得 ID &#x3D; 300；</li>
<li>再到 ID 索引树查到 ID &#x3D; 300 对应的 R3；</li>
<li>在 k 索引树取下一个值 k &#x3D; 5，取得 ID &#x3D; 500；</li>
<li>再回到 ID 索引树查到 ID &#x3D; 500 对应的 R4；</li>
<li>在 k 索引树取下一个值 k &#x3D; 6，不满足条件，循环结束。</li>
</ol>
<p>这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4），由于查询结果所需要的数据只在主键索引上有，所以 <strong>不得不回表</strong>。</p>
<p>如果执行的语句是 <code>select ID from T where k between 3 and 5</code> ，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，<strong>不需要回表</strong>。</p>
<blockquote>
<p>需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。</p>
</blockquote>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
<blockquote>
<p><strong>是否有必要将身份证号和名字建立联合索引？</strong></p>
<p>如果有根据身份证号查询市民信息的需求，只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？如果有一个高频请求，要 <strong>根据市民的身份证号查询他的姓名</strong>，用到了<strong>覆盖索引</strong>，不再需要回表查整行记录，减少语句的执行时间。</p>
<p><strong>索引字段的维护</strong>总是有代价的，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。</p>
</blockquote>
<p><strong>最左前缀原则</strong></p>
<p>建立（name，age）联合索引，<code>where name like ‘张%’</code>，能够用上这个索引，查找到第一个符合条件的记录然后向后遍历，直到不满足条件为止。</p>
<p>只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的 <strong>最左 N 个字段</strong>，也可以是字符串索引的 <strong>最左 M 个字符</strong>。</p>
<p>建立联合索引的时候，索引内的字段顺序安排的评估标准是 <strong>索引的复用能力</strong>，因为可以支持最左前缀，所以当已经有了 (a, b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p>
<p>但是如果查询条件里面只有 b 的语句，是无法使用 (a, b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a, b)、(b) 这两个索引，这时候要考虑的原则就是空间了，比如 name 字段是比 age 字段大的，则创建一个（name, age) 的联合索引和一个 (age) 的单字段索引。</p>
<p><strong>索引下推</strong></p>
<p>建立（name，age）联合索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user where name like &#x27;张 %&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure>

<p>这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录，在 MySQL 5.6 之前需要回表到主键索引上找出数据行，再对比字段值。</p>
<p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，<strong>对索引中包含的字段先做判断</strong>，直接过滤掉不满足条件的记录，<strong>减少回表次数</strong>。InnoDB <strong>在 (name, age) 索引内部就判断了 age 是否等于 10</strong>，对于不等于 10 的记录，直接判断并跳过</p>
<h3 id="唯一索引-OR-普通索引"><a href="#唯一索引-OR-普通索引" class="headerlink" title="唯一索引 OR 普通索引"></a>唯一索引 OR 普通索引</h3><p><strong>查询过程</strong></p>
<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。</li>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到<strong>第一个</strong>满足条件的记录后，就会停止继续检索。</li>
</ul>
<p>那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。</p>
<p>InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。</p>
<p>因为引擎是<strong>按页读写</strong>的，当找到满足条件的记录的时候，它所在的数据页就都在内存里了，对于普通索引来说，要<strong>多做的那一次“查找和判断下一条记录”的操作</strong>，就只需要一次指针寻找和一次计算。如果满足条件的记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这种情况的概率会很低，计算平均性能差异时，仍可以认为<strong>这个操作成本对于现在的 CPU 来说可以忽略不计</strong>。</p>
<p><strong>更新过程</strong></p>
<p>当需要更新一个数据页时：</p>
<ul>
<li><p>如果数据页在内存中就直接更新</p>
</li>
<li><p>如果数据页还没有在内存中，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 <strong>change buffer</strong> 中，这样就不需要从磁盘中读入这个数据页了，在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作（保证数据逻辑的正确性）</p>
</li>
<li><p>change buffer 是可以持久化的数据，其在内存中有拷贝，也会被写入到磁盘上，将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge</p>
</li>
<li><p>除了<strong>访问这个数据页会触发 merge 外</strong>，系统有<strong>后台线程会定期 merge</strong>。在<strong>数据库正常关闭（shutdown）的过程</strong>中，也会执行 merge 操作</p>
</li>
</ul>
<p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p>
<blockquote>
<p><strong>什么条件下可以使用 change buffer 呢？</strong></p>
<p>对于唯一索引来说，所有的更新操作都<strong>要先判断这个操作是否违反唯一性约束</strong>，而这必须要将数据页读入内存才能查找判断，如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。因此，<strong>唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</strong></p>
</blockquote>
<p>如果要在一张表中插入一个新记录，InnoDB 的处理流程：</p>
<ul>
<li><p>第一种情况是，<strong>这个记录要更新的目标页在内存中</strong>。这时，InnoDB 的处理流程如下：</p>
<ul>
<li><p>对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；</p>
</li>
<li><p>对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。</p>
</li>
<li><p>普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。</p>
</li>
</ul>
</li>
<li><p>第二种情况是，<strong>这个记录要更新的目标页不在内存中</strong>。这时，InnoDB 的处理流程如下：</p>
<ul>
<li><p>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</p>
</li>
<li><p>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</p>
</li>
<li><p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。</p>
</li>
<li><p>change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>
</li>
</ul>
</li>
</ul>
<p><strong>change buffer 的使用场景</strong></p>
<p><strong>change buffer 只限于用在普通索引的场景下</strong>，而不适用于唯一索引。</p>
<p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p>
<p>对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p>
<p>假设一个业务的更新模式是<strong>写入之后马上会做查询</strong>，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p>
<p><strong>索引选择和实践</strong></p>
<p>普通索引和唯一索引在查询能力上是没差别的，主要考虑的是对更新性能的影响，所以建议尽量选择普通索引。<strong>如果所有的更新后面，都马上伴随着对这个记录的查询</strong>，那么你应该<strong>关闭 change buffer</strong>。而在其他情况下，change buffer 都能提升更新性能。</p>
<p>普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。当有一个类似“历史数据”的库，并且出于成本考虑用的是机械硬盘时，应该特别关注这些表里的索引，尽量使用普通索引，然后把 change buffer 尽量开大，以确保这个“历史数据”表的数据写入速度。</p>
<p><strong>change buffer 和 redo log</strong></p>
<p>change buffer 是占用 InnoDB buffer pool 的空间，同时也会持久化到硬盘</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure>

<p>分析这条更新语句，它涉及了四个部分：<strong>InnoDB buffer pool、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）</strong></p>
<p>这条更新语句做了如下的操作：</p>
<ol>
<li>Page 1（k1 所在的页） 在<strong>内存</strong>中，直接更新内存；</li>
<li>Page 2（k2 所在的页）没有在内存中，就在<strong>内存的 change buffer 区域</strong>，记录下“往 Page 2 插入一行”这个信息；</li>
<li>将上述两个动作记入 redo log 中（写入磁盘）。</li>
</ol>
<p>做完上面这些，事务就可以完成了，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where k in (k1, k2)</span><br></pre></td></tr></table></figure>

<p>如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作（k1，k2）就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了</p>
<ol>
<li>读 Page 1 的时候，直接从内存返回。WAL 之后如果读数据，是不是一定要读盘，是不是一定要从 redo log 里面把数据更新以后才可以返回？其实是不用，虽然磁盘上还是之前的数据，但直接从内存返回结果，结果是正确的。</li>
<li>要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后<strong>应用 change buffer 里面的操作日志</strong>，生成一个正确的版本并返回结果，所以直到需要读 Page 2 的时候，这个数据页才会被读入内存。</li>
</ol>
<p>redo log 主要节省的是<strong>随机写</strong>磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是<strong>随机读</strong>磁盘的 IO 消耗。</p>
<h3 id="索引的选择"><a href="#索引的选择" class="headerlink" title="索引的选择"></a>索引的选择</h3><p>选择索引是优化器的工作，而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，<strong>扫描行数</strong>是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</p>
<blockquote>
<p>扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p>
</blockquote>
<h2 id="锁-🔒"><a href="#锁-🔒" class="headerlink" title="锁 🔒"></a>锁 🔒</h2><p>数据库锁设计的初衷是处理 <strong>并发问题</strong>。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则，而锁就是用来实现这些访问规则的重要数据结构。根据加锁的范围，MySQL 里面的锁大致可以分成 <strong>全局锁、表级锁和行锁</strong> 三类。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁，MySQL 提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock</code>(FTWRL)，使用这个命令之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p>全局锁的典型使用场景是，做 <strong>全库逻辑备份</strong>。也就是把整库每个表都 select 出来存成文本，但是业务就得停摆。</p>
<p>官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数 –single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的，single-transaction 方法只适用于所有的表使用事务引擎的库。</p>
<blockquote>
<p>既然要全库只读，为什么不使用 set global readonly &#x3D; true 的方式呢？</p>
<ol>
<li>在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大。</li>
<li>在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ol>
</blockquote>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级别的锁有两种：一种是<strong>表锁</strong>，一种是<strong>元数据锁</strong>（meta data lock，MDL)</p>
<p>表锁的语法是 <code>lock tables … read/write</code>。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<blockquote>
<p>如果在某个线程 A 中执行 <code>lock tables t1 read, t2 write; </code> 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。</p>
</blockquote>
<p>对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p>
<p>另一类表级的锁是 MDL（metadata lock)。<strong>MDL 不需要显式使用</strong>，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p>
<ul>
<li>读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。</li>
<li>读写锁之间、写锁之间是互斥的，用来<strong>保证变更表结构操作的安全性</strong>。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ul>
<blockquote>
<p>如何安全地给小表加字段？</p>
<p>要小心不要导致锁住线上查询和更新，如：读（未提交）写（被阻塞）读（被阻塞）…</p>
<ol>
<li>解决长事务，<strong>事务不提交，就会一直占着 MDL 锁</strong>，在 MySQL 的 information_schema 库的 innodb_trx 表中，可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</li>
<li>在 <strong>alter table 语句里面设定等待时间</strong>，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。</li>
</ol>
</blockquote>
<p>MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT&#x2F;WAIT n 这个语法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name NOWAIT add column ...</span><br><span class="line">ALTER TABLE tbl_name WAIT N add column ... </span><br></pre></td></tr></table></figure>

<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p><strong>行锁是在引擎层由各个引擎自己实现的</strong>，并不是所有的引擎都支持行锁，比如 <strong>MyISAM 引擎就不支持行锁</strong>，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p>
<p>行锁就是针对数据表中行记录的锁，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。</p>
<p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但 <strong>并不是不需要了就立刻释放</strong>，而是要 <strong>等到事务结束时才释放</strong>。这个就是两阶段锁协议。</p>
<blockquote>
<p>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放，比如电影票在线交易业务，这个业务需要涉及到以下操作：</p>
<ol>
<li>从顾客 A 账户余额中扣除电影票价；</li>
<li>给影院 B 的账户余额增加这张电影票价；</li>
<li>记录一条交易日志。</li>
</ol>
<p>要完成这个交易，需要 update 两条记录，并 insert 一条记录。为了保证交易的原子性，要把这三个操作放在一个事务中。那么，要怎样安排这三个语句在事务中的顺序呢？</p>
<p>如果同时有另外一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部分就是语句 2 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p>
<p>如果你把语句 2 安排在最后，比如按照 3、1、2 这样的顺序，那么影院 <strong>账户余额这一行的锁时间就最少</strong>。这就最大程度地 <strong>减少了事务之间的锁等待，提升了并发度</strong>。</p>
</blockquote>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个 <strong>超时时间</strong> 可以通过参数 innodb_lock_wait_timeout 来设置。</li>
<li>另一种策略是，发起 <strong>死锁检测</strong>，发现死锁后，<strong>主动回滚死锁链条中的某一个事务</strong>，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</li>
</ul>
<p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。</p>
<ul>
<li><strong>超时退出容易误伤：</strong> 对于在线服务来说，这个等待时间往往是无法接受的。但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</li>
</ul>
<p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p>
<ul>
<li><strong>死锁检测要耗费大量的 CPU 资源：</strong> 每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</li>
</ul>
<p><strong>解决办法：</strong></p>
<ul>
<li><strong>头痛医头</strong>：就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是 <strong>业务有损</strong> 的。</li>
<li><strong>控制并发度</strong>：在客户端做并发控制汇总到数据库服务端以后峰值并发数也很高，如果有中间件，可以考虑在中间件实现，基本思路就是，<strong>对于相同行的更新，在进入引擎之前排队</strong>，这样在 InnoDB 内部就不会有大量的死锁检测工作了。</li>
<li><strong>业务设计上</strong>：通过将一行改成逻辑上的多行来减少锁冲突，可以考虑放在多条记录上，比如 10 个记录，影院的 <strong>账户总额等于这 10 个记录的值的总和</strong>（和记录表不一样的），这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 <strong>1&#x2F;10</strong>，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。</li>
</ul>
<h2 id="自增-id"><a href="#自增-id" class="headerlink" title="自增 id"></a>自增 id</h2><p><strong>表定义自增值 id</strong></p>
<p><strong>InnoDB 系统自增 row_id</strong></p>
<p><strong>Xid</strong></p>
<p><strong>Innodb trx_id</strong></p>
<p><strong>thread_id</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100020801">MySQL 实战 45 讲</a></strong></li>
</ul>


<!-- 
<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div> -->

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/06/29/ahttp/">Hypertext Transfer Protocol (HTTP) 🌐</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/06/15/cc/">「云计算」背景知识概览 ☁️</a></div></section></div>






  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" data-repo="hcjjj/blog-comments" data-repo-id="R_kgDOM8H5Mg" data-category="Announcements" data-category-id="DIC_kwDOM8H5Ms4CjGw7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>



      <!-- 
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@anonymity</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer> -->

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadJS() {
    const els = document.querySelectorAll("#comments #giscus");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://giscus.app/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    loadJS();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
