<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 7.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>《深入架构原理与实践》📖✍🏻 - H-sediment</title>

  
    <meta name="description" content="一本关于架构的开源书籍：https:&#x2F;&#x2F;www.thebyte.com.cn">
<meta property="og:type" content="article">
<meta property="og:title" content="《深入架构原理与实践》📖✍🏻">
<meta property="og:url" content="http://example.com/2024/10/28/availability/index.html">
<meta property="og:site_name" content="H-sediment">
<meta property="og:description" content="一本关于架构的开源书籍：https:&#x2F;&#x2F;www.thebyte.com.cn">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/cloud-C6z_sZLk.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/Curl-logo.svg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/networking-CafBaqd-.svg">
<meta property="article:published_time" content="2024-10-28T09:10:55.000Z">
<meta property="article:modified_time" content="2025-02-24T11:09:28.543Z">
<meta property="article:author" content="hcjjj">
<meta property="article:tag" content="availability">
<meta property="article:tag" content="architecture">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/cloud-C6z_sZLk.svg">
  
  
  
  <meta name="keywords" content="availability,architecture">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/icon.png">
  

  

  
    <link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
    <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
    <script defer src="https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"onload="renderMathInElement(document.body);"></script>
  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">H-sediment</div><div class="sub cap">dust in the wind</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">文章</a><a class="nav-item" href="/about/">About</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">《深入架构原理与实践》📖✍🏻</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E4%BA%91%E5%8E%9F%E7%94%9F%E6%8A%80%E6%9C%AF%E6%A6%82%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章：云原生技术概论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E6%BC%94%E8%BF%9B%E5%8F%98%E9%9D%A9"><span class="toc-number">1.1.</span> <span class="toc-text">云计算的演进变革</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E5%87%BA%E7%8E%B0%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">云原生出现的背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%9B%AE%E6%A0%87"><span class="toc-number">1.3.</span> <span class="toc-text">云原生的定义与目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E4%BB%A3%E8%A1%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88"><span class="toc-number">1.4.</span> <span class="toc-text">云原生代表技术概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">1.5.</span> <span class="toc-text">云原生架构技术栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9E%84%E5%BB%BA%E2%80%9C%E8%B6%B3%E5%A4%9F%E5%BF%AB%E2%80%9D%E7%9A%84%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.</span> <span class="toc-text">第二章: 构建“足够快”的网络服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">HTTPS 优化分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">域名解析的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BC%A0%E8%BE%93%E5%86%85%E5%AE%B9%E8%BF%9B%E8%A1%8C%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.3.</span> <span class="toc-text">对传输内容进行压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.4.</span> <span class="toc-text">HTTPS 原理及实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5-Linux-%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF"><span class="toc-number">3.</span> <span class="toc-text">第三章：深入 Linux 内核网络技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI-%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">OSI 网络分层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%B3%BB%E7%BB%9F%E6%94%B6%E5%8C%85%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">Linux 系统收包流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">4.</span> <span class="toc-text">第四章：负载均衡技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">负载均衡概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">负载均衡调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%8B%93%E6%89%91%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">负载均衡拓扑类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">4.4.</span> <span class="toc-text">四层负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">4.5.</span> <span class="toc-text">七层负载均衡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">第五章：数据一致性与分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">数据一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-number">5.2.</span> <span class="toc-text">一致性与可用性的权衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">分布式事务模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.4.</span> <span class="toc-text">服务幂等性设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E5%8F%8A%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">第六章：分布式共识及算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E6%8A%80%E6%9C%AF"><span class="toc-number">7.</span> <span class="toc-text">第七章：容器编排技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E6%8A%80%E6%9C%AF"><span class="toc-number">8.</span> <span class="toc-text">第八章：服务网格技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E7%B3%BB%E7%BB%9F%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7"><span class="toc-number">9.</span> <span class="toc-text">第九章：系统可观测性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-GitOps-%E7%90%86%E5%BF%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AE%BE%E8%AE%A1"><span class="toc-number">10.</span> <span class="toc-text">第十章 GitOps 理念与实现设计</span></a></li></ol></div></div></widget>




</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/hcjjj" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg"/></a><a class="social" href="/hcjjj@foxmail.com" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg"/></a><a class="social" href="/H_sediment" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg"/></a><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3845874.svg"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      


  
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@v10/dist/mermaid.min.js"></script>

  <script>
    var mermaid_config = {
      startOnLoad: true,
      theme:
        "auto" == "auto" &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "neutral",
      logLevel: 3,
      themeVariables: {
        darkMode: true
      },
      flowchart: {
        useMaxWidth: false,
        htmlLabels: true,
        curve: "linear"
      },
      gantt: {
        axisFormat: "%Y/%m/%d"
      },
      sequence: {
        actorMargin: 50
      }
    }
    if (window.mermaid) {
      mermaid.initialize(mermaid_config);
    }
  </script>




<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Reading/">Reading</a></div><div id="post-meta">发布于&nbsp;<time datetime="2024-10-28T09:10:55.000Z">2024-10-28</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>《深入架构原理与实践》📖✍🏻</span></h1>
<p>一本关于架构的开源书籍：<a target="_blank" rel="noopener" href="https://www.thebyte.com.cn/">https://www.thebyte.com.cn</a></p>
<span id="more"></span>

<h1 id="深入架构原理与实践"><a href="#深入架构原理与实践" class="headerlink" title="深入架构原理与实践"></a>深入架构原理与实践</h1><h2 id="第一章：云原生技术概论"><a href="#第一章：云原生技术概论" class="headerlink" title="第一章：云原生技术概论"></a>第一章：云原生技术概论</h2><h3 id="云计算的演进变革"><a href="#云计算的演进变革" class="headerlink" title="云计算的演进变革"></a>云计算的演进变革</h3><ul>
<li><strong>物理机时代</strong>，业务的工作负载是整台物理机，资源没有隔离，也完全没有服务&#x2F;资源供应商一说</li>
<li><strong>虚拟化技术成熟</strong>，可以在一台物理机器上运行多个虚拟机<ul>
<li>1959 年，Christopher Strachey 在国际信息处理大会上发表《Time Sharing in Large Fast Computer》论文，首次提出了“虚拟化”的概念</li>
<li>如果业务需要扩容，那就再开通一个虚拟机，整个过程只要几分钟</li>
<li>业务的工作负载由物理机转向虚拟机，资源有了初级的隔离，并且分配&#x2F;利用更加合理，服务部署的速度和弹性也远超物理机</li>
</ul>
</li>
<li><strong>云计算技术成熟</strong>，虚拟化技术的成熟使得云计算市场开始真正形成<ul>
<li>2006 年 8 月 9 日，Google 首席执行官 Eric Schmidt 在搜索引擎大会（SES San Jose 2006）首次提出“云计算”（Cloud Computing）的概念</li>
<li>基于虚拟化技术诞生了众多的云计算产品，陆续出现了 IaaS、PaaS、SaaS 以及公有云、私有云、混合云等多种云服务模型</li>
</ul>
</li>
<li><strong>容器技术的兴起</strong>，打破了 PaaS 行业面临应用分发和交付的困境，大力推动了云原生的发展<ul>
<li>2013 年，Docker 发布，容器逐步替代虚拟机（Virtual Machine，VM），云计算进入容器时代</li>
<li>2017 年底，Kubernetes 赢得容器编排的胜利，云计算进入 Kubernetes 时代</li>
<li>云计算从仅提供计算、存储、网络资源的初级阶段，发展成为具备强大软件交付和维护能力的综合性服务平台</li>
</ul>
</li>
<li><strong>云计算的演进总结</strong><ul>
<li>工作负载的变化：从早期的 <strong>物理服务器</strong>，通过虚拟化技术演进为 <strong>虚拟机</strong>，再通过容器化技术演进为目前的 <strong>容器</strong></li>
<li>隔离单元：无论是启动时间还是单元大小，物理机、虚拟机、容器一路走来，实现了 <strong>从重量级到轻量级的转变</strong></li>
<li>供应商：从闭源到开源（从 VMware 到 KVM、OpenStack，再到 Kubernetes）从单一供应商到跨越多个供应商（从公有云到自建云，再到混合云）</li>
</ul>
</li>
</ul>
<h3 id="云原生出现的背景"><a href="#云原生出现的背景" class="headerlink" title="云原生出现的背景"></a>云原生出现的背景</h3><ul>
<li><strong>软件正在吞噬世界</strong><ul>
<li>2011 年 8 月 20 日华尔街日报上，Mark Andreessen 发表了名为“Why Software Is Eating the World”的文章</li>
<li>部分软件已经变成水电煤一样的社会经济中的基础设施</li>
</ul>
</li>
<li><strong>移动互联网在加剧变化</strong><ul>
<li>按照 <strong>规模和变更速度</strong> 将软件企业划分为四个象限&#x2F;四种类型<ul>
<li>企业 IT（Enterprise IT）：规模小、变化慢，容易处理</li>
<li>电信（Telcos）：规模大、变化慢，主要应对硬件失败</li>
<li>初创公司（Startups）：规模小、<strong>变化快</strong>，主要应对软件失败</li>
<li>网络规模的互联网企业（Web-Scale）：规模大、<strong>变化快</strong>，软硬件或者说所有东西都会出问题</li>
</ul>
</li>
<li>移动互联网时代的用户规模已经开始向人口基数看齐，开始出现各类亿级 DAU 规模的移动应用</li>
<li>在移动互联网时代，能够成长并发展起来的这些公司，它们的共同点是：<ul>
<li>快速变更，不断创新，随时调整</li>
<li>提供持续可用的服务，应对各种可能的错误和中断</li>
<li>弹性可扩展的系统，应对用户规模的快速增长</li>
<li>提供新的用户体验，以移动为中心</li>
</ul>
</li>
<li>这样的背景下，对软件质量有了更高的要求，首当其冲的就是 <strong>如何解决规模越来越大同时变更越来越快的难题</strong></li>
</ul>
</li>
<li><strong>云原生诞生</strong><ul>
<li><strong>软件对各行各业的渗透和对世界的改变，以及移动互联网时代巨大的用户基数下快速变更和不断创新的需求</strong> 对软件开发方式带来的巨大推动力</li>
<li>在过去二十年，云的底层基础设施和平台越来越强大，<strong>软件架构的发展也逐渐和云匹配</strong>：<ul>
<li>通过不可变基础设施（镜像）解决本地和远程一致性问题</li>
<li>通过服务网格（ServiceMesh）将非业务逻辑从应用程序中剥离</li>
<li>通过声明式 API 描述应用程序的状态，而不用管中间的处理过程</li>
<li>通过 DevOps 方法论以及一系列工具来提升研发&#x2F;运维效率</li>
</ul>
</li>
<li>应用程序中的非业务逻辑不断被剥离，并下沉到云&#x2F;基础设施层，代码越来越轻量，工程师的开发工作回归本质</li>
<li>软件开发的本质是 <strong>解决业务需求</strong>，各类“高深”、“复杂”的技术难题是 <strong>业务需求的副产物</strong>，并不是软件开发的主题</li>
</ul>
</li>
</ul>
<h3 id="云原生的定义与目标"><a href="#云原生的定义与目标" class="headerlink" title="云原生的定义与目标"></a>云原生的定义与目标</h3><blockquote>
<p>云原生是一个组合词，“云”表示应用程序运行于分布式云环境中，“原生”表示应用程序在设计之初就充分考虑到了云平台的弹性和分布式特性，充分利用云计算优势对应用程序进行设计、实现、部署、交付的理念方法</p>
</blockquote>
<ul>
<li>2015 年，来自 Pivotal 公司的技术产品经理 Matt Stine，首次提出了云原生（Cloud Native）的概念</li>
<li>在 Pivotal 最新的官方网站中，对云原生的介绍则是关注 4 个要点：<ul>
<li>DevOps（开发运维）</li>
<li>Continuous Delivery（持续交付）</li>
<li>Microservices（微服务）</li>
<li>Containers（容器化）</li>
</ul>
</li>
<li>CNCF 对云原生的定义<ul>
<li>2015 年 CNCF（Cloud Native Computing Foundation，云原生计算基金会）建立，开始围绕云原生的概念打造云原生生态体系</li>
<li>CNCF 是 Linux 基金会旗下的基金会，成立这个组织的初衷或者愿景是推动云原生计算可持续发展，帮助云原生技术开发人员快速地构建出色的产品</li>
<li>起初 CNCF 对云原生的定义包含以下三个方面：<ul>
<li><pre><code>应用容器化：容器化是云原生的基础
</code></pre>
</li>
<li><pre><code>面向微服务架构：实施微服务是构建大规模系统的必备要素
</code></pre>
</li>
<li><pre><code>应用支持容器的编排调度：编排调度是指能够对容器应用的部署、扩展、运行和生命周期进行自动化管理
</code></pre>
</li>
</ul>
</li>
<li>2018 年 6 月，CNCF 正式对外公布了更新之后的云原生的定义 v1.0 版本：<ul>
<li><pre><code>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用
</code></pre>
</li>
<li><pre><code>云原生的代表技术包括：容器、服务网格、微服务、不可变基础设施和声明式 API
</code></pre>
</li>
<li><pre><code>这些技术能够构建 容错性好、易于管理和便于观察的松耦合系统
</code></pre>
</li>
<li><pre><code>结合可靠的 自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>云原生的定义是什么并不重要，关键还是理解实施云原生有什么好处，以及实施云原生所涉及的技术&#x2F;工具、架构设计的依据等</li>
</ul>
<p>云原生的目标主要是帮助企业和开发者 构建、运行和管理现代化应用，以便在云环境中实现高效、敏捷和弹性的业务交付</p>
<ul>
<li><strong>可用（Available）</strong>：通过各种机制来实现应用的高可用，以保证服务提供的连续性</li>
<li><strong>规模（Scale）</strong>：能够适应不同的规模（包括但不限于用户规模&#x2F;部署规模&#x2F;请求量），并能够在部署时动态分配资源，以便在不同的规模之间快速和平滑的伸缩，典型场景如：<ul>
<li>初创公司或新产品线快速成长，用户规模和应用部署规模在短时间内十倍百倍增长</li>
<li>促销、季节性、节假日带来的访问量波动</li>
<li>高峰时间段的突发流量等</li>
</ul>
</li>
<li><strong>敏捷（Agility）</strong>：快速响应市场需求</li>
<li><strong>成本（Cost）</strong>：充分有效的利用资源</li>
</ul>
<p>这 4 个核心目标之间，存在彼此冲突的情况：</p>
<ul>
<li>规模和敏捷之间的冲突：<strong>规模大而又要求敏捷</strong>，比喻为“巨人绣花”</li>
<li>规模和可用性之间的冲突：<strong>规模大而要求可用性高</strong>，比喻为“大象起舞”</li>
<li>敏捷和可用性之间的冲突：<strong>敏捷而要求高可用</strong>，比喻为“空中换发”</li>
</ul>
<p>而云原生架构必须要在同时满足这 3 个彼此冲突目标的前提下，还要实现成本控制</p>
<h3 id="云原生代表技术概览"><a href="#云原生代表技术概览" class="headerlink" title="云原生代表技术概览"></a>云原生代表技术概览</h3><ul>
<li><strong>容器技术</strong><ul>
<li>chroot 阶段：隔离文件系统<ul>
<li>一个叫做 chroot（Change Root）的系统调用被认为是最早的容器化技术之一</li>
<li>可以重定向进程及其子进程的 root 目录到文件系统上的新位置，即分离每个进程的 <strong>文件访问权限</strong>，使得该进程无法接触到外面的文件</li>
<li>通过 chroot 隔离出来的新环境得到了一个非常形象的命名 Jail（监狱），这便是容器最重要的特性 —— 隔离</li>
</ul>
</li>
<li>LXC 阶段：封装系统<ul>
<li>2008 年 Linux 内核版本 2.6.24 刚开始提供 cgroups（Control Groups），提供操作系统级别的 <strong>资源限制</strong>、优先级控制、资源审计和进程控制能力</li>
<li>社区开发者就将 cgroups 资源管理能力和 Linux namespace <strong>资源隔离</strong> 能力组合在一起，形成了完整的容器技术 LXC（Linux Container）</li>
</ul>
</li>
<li>Docker 阶段：封装应用<ul>
<li>Docker 的核心创新“容器镜像（container image）”<ul>
<li>容器镜像打包了整个容器运行依赖的环境，以避免依赖运行容器的服务器的操作系统，从而实现“build once，run anywhere”</li>
<li>容器镜像一但构建完成，就变成只读状态，成为不可变基础设施的一份子</li>
<li>与操作系统发行版无关，核心解决的是容器进程对操作系统包含的库、工具、配置的依赖（注意，容器镜像 <strong>无法解决容器进程对内核特性的特殊依赖</strong>）</li>
</ul>
</li>
<li>开发者基于镜像打包应用所依赖的环境，而不是改造应用来适配 PaaS 定义的运行环境</li>
<li>现阶段容器技术体系已经解决了 <strong>最核心的两个问题“如何运行软件和如何发布软件”</strong>，云计算开始进入容器阶段</li>
</ul>
</li>
<li>OCI 阶段：容器标准化<ul>
<li>Linux 基金会联合 Docker 带头成立 OCI（Open Container Initiative，开放容器标准）项目</li>
<li>OCI 组织着力解决容器的构建、分发和运行标准问题，其宗旨是制定并维护 OCI Specifications（容器镜像格式和容器运行时的标准规范）</li>
</ul>
</li>
<li>容器编排阶段：封装集群<ul>
<li>以 Docker 为代表的容器引擎，是把软件的发布流程从分发二进制安装包，转变为了直接分发虚拟化后的整个运行环境</li>
<li>以 Kubernetes 为代表的容器编排框架，就是把大型软件系统运行所依赖的集群环境也进行了虚拟化</li>
</ul>
</li>
<li>云原生阶段：百花齐放<ul>
<li>2015 年 7 月 21 日，Google 带头成立了 Cloud Native Computing Foundation（CNCF，云原生基金会）</li>
<li>OCI 和 CNCF 这两个围绕容器的基金会共同制定了一系列行业事实标准，基于接口标准的具体实现不断涌现，呈现出一片百花齐放的景象</li>
</ul>
</li>
</ul>
</li>
<li><strong>微服务</strong><ul>
<li>微服务架构是一种面向服务的架构，由松耦合的具有有限上下文的元素组成<ul>
<li>松耦合（Loosely Coupled）：意味着每个服务可以独立的更新，更新一个服务无需要求改变其他服务</li>
<li>限界上下文（Bounded Contexts）：意味着每个服务要有明确的边界性，你可以只关注自身软件的发布，而无需考虑谁在依赖你的发布版本</li>
<li>微服务和它的消费者严格通过 API 进行交互，不共享数据结构、数据库等，基于契约的微服务规范要求服务接口是稳定的，而且向下兼容</li>
<li>微服务架构的特征是：服务之间独立部署，拥有各自的技术栈，各自界定上下文</li>
</ul>
</li>
<li>微服务带来的技术挑战<ul>
<li>微服务架构首先是一个分布式的架构，软件架构从巨石应用向微服务架构转型的过程中带来了一系列的非功能性需求，例如：<ul>
<li>服务发现（Service Discovery）问题：解决“我想调用你，如何找到你”的问题</li>
<li>服务熔断（Circuit Breaker）问题：缓解服务之间依赖的不可靠问题</li>
<li>负载均衡（Load Balancing）问题：通过均匀分配流量，让请求处理更加及时</li>
<li>安全通讯问题：包括协议加密（TLS）、身份认证（证书&#x2F;签名）、访问鉴权（RBAC）等</li>
</ul>
</li>
<li>解决这些问题需要编写和维护大量非功能性代码，这些代码与业务代码逻辑混在一起，基础设施不完善的话，实施微服务会很痛苦，服务越多越悲剧</li>
</ul>
</li>
<li>后微服务时代<ul>
<li>之所以选择在应用服务层面，而非基础设施层面去解决这些分布式问题，主要是 <strong>因为硬件构建的基础设施无法追赶上软件构成的应用服务的灵活性</strong></li>
<li>被业界广泛认可、普遍采用的 <strong>通过虚拟化基础设施去解决分布式架构问题</strong> 的开端，应该要从 2017 年 Kubernetes 赢得容器战争的胜利开始算起</li>
<li>一旦虚拟化的硬件能够跟上软件的灵活性，那些与业务无关的技术性问题便有可能从软件层面剥离，并悄无声息地解决于硬件基础设施之内</li>
<li>但对于 Kubernetes，由于基础设施粒度更粗糙，通常只能管理到容器层面，对单个远程服务的有效管理就相对困难，服务的监控、认证、授权、安全、负载均衡等都有可能面临细化管理的需求</li>
<li>为了解决这一类问题，微服务基础设施很快进行了第二次进化，引入了今天被称为“服务网格”（Service Mesh）的模式</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务网格</strong><ul>
<li>服务网格（ServiceMesh）是一个 <strong>基础设施层</strong>，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格保证 <strong>请求在这些拓扑中可靠地穿梭</strong>。在实际应用当中，服务网格通常是由一系列轻量级的 <strong>网络代理</strong> 组成的，它们与应用程序部署在一起，但 <strong>对应用程序透明</strong></li>
<li>服务网格的关键在于 Sidecar 模式，服务网格将具有流控能力的网络代理以 Sidecar 的方式部署，各个微服务之间通过 Sidecar 发现和调用目标服务，从而在服务之间形成一种网络状依赖关系</li>
<li>在 Kubernetes 的工作负载 Pod 中可以运行多个容器，其中 <strong>所有业务容器之外的其他容器均可称为 Sidecar</strong>，如日志收集 Sidecar、请求代理 Sidecar 和链路追踪 Sidecar 等</li>
<li>服务网格本质是通过 iptables 劫持发送到应用容器的流量，将原本在业务层处理的分布式通信治理相关的技术问题，下沉到具有流控能力的 Sidecar 中处理，<strong>实现业务与非业务逻辑解耦</strong> 的目的</li>
</ul>
</li>
<li><strong>不可变基础设施</strong><ul>
<li>“可变”的基础实施与传统运维操作相关，比如手动对服务器进行变更，部署的是 Apache，换成 Nginx（在原有的基础上做原地更新）</li>
<li>不可变基础设施的 <strong>核心思想是任何基础设施的运行实例一旦创建之后就变成只读状态</strong>，如需修改应先修改基础设施的配置模版（例如 yaml、Dockerfile）</li>
<li>从容器的角度看，<strong>镜像就是一个不可变基础设施</strong>，开发工程师交付的产物从一个有着各种依赖条件的安装包变成一个不依赖任何环境的镜像文件</li>
<li>对比可变基础设施，<strong>不可变基础设施的最大的优势是一致性</strong>，快速拉起成千上万一模一样的服务，服务的版本升级、回滚也成为常态</li>
</ul>
</li>
<li><strong>声明式设计</strong><ul>
<li>声明式设计是一种软件设计理念和做法：“向一个工具描述想要让一个事物达到的目标状态，由工具内部去解决如何令这个事物达到目标状态”</li>
<li>命令式设计：命令“机器”如何去做事情（how），这样不管你想要的是什么（what），它都会按照你的命令实现</li>
<li>声明式设计：告诉“机器”你想要的是什么（what），让机器想出如何去做（how），比如 SQL、Kubernetes 的 YAML</li>
</ul>
</li>
<li><strong>DevOps</strong><ul>
<li>发展，瀑布 → 敏捷<ul>
<li>瀑布开发，该模型下整个软件开发流程严格遵循需求、设计、开发、测试和部署几个阶段，需要等上一个阶段完成工作后，才会进行下一阶段的工作</li>
<li>敏捷开发，一种持续增量、不断迭代的开发模式，快速发布一个可运行但不完美的版本投入市场，在后续迭代中根据用户的反馈改进产品，从而逼近产品的最终形态</li>
<li>迭代是敏捷开发理论的核心，具体的敏捷研发方法有极限编程、精益软件开发、Scrum 等</li>
</ul>
</li>
<li>DevOps 出现的背景<ul>
<li>虽然敏捷开发提升了开发效率，但它的范围仅限于开发和测试阶段，并没有覆盖到部署端，运维部门并没有在这其中得到收益</li>
<li>相反的，甚至可以说“敏捷”加重了运维的负担。因为运维追求的目标是稳定，而频繁的变更往往就是出现问题的根源</li>
</ul>
</li>
<li>从存在的意义上说，DevOps 完善了敏捷开发存在的短板，实现了真正的闭环<ul>
<li>DevOps（Development 和 Operations 的合成词）是一种重视“软件开发人员（Dev）”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例</li>
<li>通过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠</li>
<li>运维会在项目开发阶段就介入，了解开发所使用的系统架构和技术路线，并制定好相关的运维方案；而开发人员也会参与到后期的系统部署和日常发布中，并提供优化建议，而不再是把代码甩给运维了事</li>
<li>DevOps 的成功实践也离不开工具的支持，这其中就包括最重要的自动化 CI&#x2F;CD 流水线，通过自动化的方式打通软件从构建、测试到部署发布的整个流程，还有包括实时监控、事件管理、配置管理、协作平台等一系列工具的配合</li>
</ul>
</li>
<li>微服务架构理念、容器技术和云计算的发展，让 DevOps 的实施更加便捷，这也解释了为何 DevOps 理念在十多年前就已提出，但直到近几年才开始被企业广泛关注和实践</li>
</ul>
</li>
</ul>
<p><strong>传统架构向云原生架构的演进之路</strong></p>
<ul>
<li><p>为了解决单体架构“复杂度问题”，使用微服务架构</p>
</li>
<li><p>为了解决微服务间“通讯异常问题”，使用治理框架 + 监控</p>
</li>
<li><p>为了解决微服务架构下大量应用“部署问题”，使用容器</p>
</li>
<li><p>为了解决容器的“编排和调度问题”，使用 Kubernetes</p>
</li>
<li><p>为了解决微服务框架的“侵入性问题”，使用服务网格</p>
</li>
<li><p>为了让服务网格有“更好的底层支撑”，将服务网格运行在 Kubernetes 上</p>
</li>
</ul>
<p>但站在整个系统的角度看，复杂度并没有减少和消失，要实现“强大底层系统”付出的成本（人力成本、资源成本、技术试错成本）是非常昂贵的，为了降低成本，选择上云托管，将底层系统的复杂度交给云基础设施，让云提供保姆式服务，最终演变为无基础架构设计</p>
<h3 id="云原生架构技术栈"><a href="#云原生架构技术栈" class="headerlink" title="云原生架构技术栈"></a>云原生架构技术栈</h3><div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/cloud-C6z_sZLk.svg" fancybox="true"/></div></div>

<h2 id="第二章-构建“足够快”的网络服务"><a href="#第二章-构建“足够快”的网络服务" class="headerlink" title="第二章: 构建“足够快”的网络服务"></a>第二章: 构建“足够快”的网络服务</h2><p><strong><a target="_blank" rel="noopener" href="https://colin-scott.github.io/personal_website/research/interactive_latency.html">Latency Numbers Every Programmer Should Know</a></strong></p>
<blockquote>
<p>秒(s)、毫秒(ms)、微秒 (μs)、纳秒 (ns）之间关系：$1s &#x3D; 10^3ms&#x3D;10^6μs&#x3D;10^9ns$</p>
</blockquote>
<h3 id="HTTPS-优化分析"><a href="#HTTPS-优化分析" class="headerlink" title="HTTPS 优化分析"></a>HTTPS 优化分析</h3><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/Curl-logo.svg" style="zoom:33%;" />

<blockquote>
<p><strong>cURL</strong> 是一个开源项目，主要的产品是 curl（命令行工具）和 libcurl（C 语言的 API 库），两者功能均是：基于网络协议，对指定 URL 进行网络传输</p>
</blockquote>
<ul>
<li>请求阶段分析<ul>
<li>一个完整、未复用连接的 HTTPS 请求需要经过以下 5 个阶段：DNS 域名解析、TCP 握手、SSL 握手、服务器处理、内容传输</li>
</ul>
</li>
<li>各阶段耗时分析<ul>
<li>HTTPS 请求的各个阶段可以使用 <strong>curl</strong> 命令进行详细的延迟分析</li>
</ul>
</li>
<li>HTTPS 的优化总结<ul>
<li>域名解析优化：减少域名解析产生的延迟，例如使用预解析提前获取域名解析结果，那么 HTTPS 连接就能减少一个 RTT</li>
<li>对传输内容进行压缩：传输数据的大小与耗时成正比，压缩传输内容是降低请求耗时最有效的手段之一</li>
<li>SSL 层优化：升级 TLS 算法和 HTTPS 证书，例如升级 TLS 1.3 协议，可将 SSL 握手的 RTT 从 2 个减少到 1 个</li>
<li>传输层优化：升级拥塞控制算法以提高网络吞吐量，将默认的 Cubic 升级为 BBR 对于大带宽、长链路的弱网环境尤其有效</li>
<li>网络层优化：使用商业化的网络加速服务，通过路由优化数据包，实现动态服务加速</li>
<li>使用更现代的 HTTP 协议：升级至 HTTP&#x2F;2，进一步升级到基于 QUIC 协议的 HTTP&#x2F;3</li>
</ul>
</li>
</ul>
<blockquote>
<p>RTT（Round-Trip Time）一个网络数据包从起点到目的地然后再回到起点所花费的时长</p>
</blockquote>
<h3 id="域名解析的原理"><a href="#域名解析的原理" class="headerlink" title="域名解析的原理"></a>域名解析的原理</h3><p>DNS（Domain Name System，域名系统）是互联网中最重要的基础设施，它的主要职责是实现域名的解析，也就是 <strong>将域名转换为 IP 地址</strong></p>
<pre class="mermaid">graph TB
    root["."] --- com[".com"]
    root --- org[".org"]
    root --- be[".be"]
    com --- google["google.com"]
    com --- chess["chess.com"]
    be --- linux["linux-training.be"]

    %% 样式定义
    style root fill:#FFFFFF,stroke:#333,stroke-width:2px
    style com fill:#FFDDC1,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style org fill:#FFDDC1,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style be fill:#FFDDC1,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style google fill:#D4E4FF,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style chess fill:#D4E4FF,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style linux fill:#D4E4FF,stroke:#333,stroke-width:2px,rx:10px,ry:10px

    %% 连接线样式
    linkStyle default stroke:#FF6347,stroke-width:2px,stroke-opacity:0.8</pre>

<p>域名是一种 <strong>树状结构</strong>，最顶层的域名是根域名（注意是一个点“.”，它是 .root 的含义，不过现在“.root”已经默认被隐藏），然后是顶级域名（Top Level Domain，简写 TLD，例如 .com），再是二级域名（例如 google.com）</p>
<p>通常情况下的域名解析过程，其实就是从“域名树”的根部到顶部，不断 <strong>递归查询</strong> 的过程：</p>
<ol>
<li>用户向“DNS 解析器”（Recursive resolver）发出解析域名请求，“DNS 解析器”也称 LocalDNS，例如电信运营商的 114.114.114.114</li>
<li>“DNS 解析器” 判断是否存在解析缓存<ol>
<li>如存在，直接返回缓存的结果</li>
<li>如不存在，向就近的“根域名服务器”查询域名所属“TLD 域名服务器”（Top-Level Domains nameserver）</li>
</ol>
</li>
<li>根域名服务器返回相应的 TLD 域名服务器地址</li>
<li>“DNS 解析器”向 TLD 服务器请求该域名的“权威域名服务器”（Authoritative nameserver）</li>
<li>TLD 服务器返回权威域名服务器的地址</li>
<li>“DNS 解析器”向权威域名服务器查询域名的具体解析记录（如 A 记录或 CNAME 记录）</li>
<li>获取解析记录后，“DNS 解析器”将结果返回给用户</li>
</ol>
<pre class="mermaid">sequenceDiagram
    participant Client as 用户
    participant Resolver as DNS 解析器 (LocalDNS)
    participant Root as 根域名服务器
    participant TLD as TLD 域名服务器
    participant Authoritative as 权威域名服务器

    Client->>Resolver: 请求解析域名
    alt 存在缓存
        Resolver->>Client: 返回缓存的结果
    else 不存在缓存
        Resolver->>Root: 查询 TLD 域名服务器
        Root->>Resolver: 返回 TLD 域名服务器地址
        Resolver->>TLD: 查询权威域名服务器
        TLD->>Resolver: 返回权威域名服务器地址
        Resolver->>Authoritative: 查询域名解析记录
        Authoritative->>Resolver: 返回解析记录
        Resolver->>Client: 转发解析记录
    end</pre>



<blockquote>
<p>实际上“根域名服务器”的数量远不止 13 台，截止 2024 年 7 月，全世界共有 1,845 台根域名服务器</p>
<p>权威域名服务器通常是指顶级域名以下的管理二级、三级、四级等域名的服务器，多个域名解析到同一个 IP 地址（通过 CNAME 记录），服务器仍然可以根据 <strong>Host</strong> 头信息准确区分并响应不同的请求</p>
</blockquote>
<p><strong>域名解析故障时排查</strong></p>
<p>如果请求一个 HTTPS 接口，出现服务不可用、Unknown host 等错误时，除了用 ping 测试连通性外，可以用 <strong>nslookup</strong> 或者 <strong>dig</strong> 命令确认域名解析是否出现问题</p>
<ul>
<li>nslookup 返回的结果比较简单，但从中可以看出用的哪个“DNS 解析器”，域名的解析是否正常</li>
<li>当怀疑系统默认的“DNS 解析器”异常时，可以使用 dig 命令，通过切换不同的“DNS 解析器”，分析解析哪里出现异常</li>
</ul>
<p><strong>使用 HTTPDNS 解决“中间商”问题</strong><br>“域名解析器”是 DNS 查询中的第一站，它作为客户端与“域名服务器”的中间人帮我们去整棵 DNS 树上进行解析，然后将解析的结果返回给客户端<br>但作为一个“中间商”，“域名解析器”很容易出现域名劫持、解析时间过长、解析调度不精准等问题，这些问题的根源在于 <strong>域名解析经历了过多的中间环节，服务质量不可控</strong>，为了解决上述问题，一种新型的 DNS 解析模式 —— HTTPDNS 应运而生</p>
<p>HTTPDNS 的工作原理：</p>
<ul>
<li>客户端内部集成 HTTPDNS 模块，跳过“操作系统定义的解析服务”（LocalDNS，也就是默认基于 UDP 协议的域名解析系统）</li>
<li>替换为使用 HTTPS 协议请求更可靠的“软件定义的解析服务”，直接从“<strong>权威域名服务器</strong>”同步解析记录</li>
<li>避免了“中间商赚差价”，逻辑更可控，也能准确判断客户端地区和运营商，得到更精准的解析结果<br>通过使用 HTTPDNS ，再结合客户端解析缓存、热点域名预解析、懒加载等优化策略，能明显改善传统域名解析带来的各类问题</li>
</ul>
<h3 id="对传输内容进行压缩"><a href="#对传输内容进行压缩" class="headerlink" title="对传输内容进行压缩"></a>对传输内容进行压缩</h3><p>对传输内容进行压缩是提升 HTTP 服务可用性的关键手段，一般使用 Gzip 对内容进行压缩，但针对 HTTP 类型的文本内容还有一个更高压缩率的算法 Brotli，压缩效果 Gzip 高出 17% - 30%</p>
<pre class="mermaid">sequenceDiagram
    autonumber
    participant Client as Client
    participant Server as Server

    Client->>+Server: 请求资源<br>GET /doc HTTP/1.1<br>Accept-Encoding: br, gzip
    Note right of Client: 客户端通过<br>Accept-Encoding<br>告知服务器支持<br>压缩算法：br, gzip

    Server-->>-Client: 返回资源<br>HTTP/1.1 200 OK<br>Content-Encoding: br<br>Vary: Accept-Encoding
    Note left of Server: 服务器通过 Vary<br>告知客户端资源已<br>使用 br 算法压缩</pre>



<h3 id="HTTPS-原理及实践"><a href="#HTTPS-原理及实践" class="headerlink" title="HTTPS 原理及实践"></a>HTTPS 原理及实践</h3><p><strong>HTTPS 加密原理</strong></p>
<p><strong>非对称加密</strong> 算法通常需要更多的计算资源，尤其在加密或解密大量数据时计算消耗更大。因此使用计算效率更高的 <strong>对称加密</strong> 算法来加密 HTTP 内容，非对称加密算法来加密对称加密的密钥：</p>
<ol>
<li>客户端与服务端会进行协商，确定一个双方都支持的对称加密算法，例如 AES</li>
<li>确认对称加密算法后，客户端会随机生成一个对称加密密钥 K</li>
<li>客户端使用服务端的公钥加密密钥 K，并将密文传输给服务端，此时，只有服务端的私钥能够解密密钥 K</li>
</ol>
<p>实现了”降低加&#x2F;解密的耗时，同时又保证密钥传输的安全性“，，达成既要安全又要效率的目标 <strong>（机密性 + 完整性）</strong>，但“如何将服务器公钥传输给客户端呢？”</p>
<p>公钥仍有被劫持的可能性：</p>
<pre class="mermaid">sequenceDiagram
    participant Client as Client
    participant Middle as Middle
    participant Server as Server

    Client->>Server: 请求公钥
    Server->>Middle: 发送公钥
    Middle->>Client: 替换公钥
    Client->>Client: 本地保存假公钥
    Client->>Middle: 假公钥加密 hello
    Middle->>Middle: 内容篡改
    Middle->>Server: 真公钥加密 hi
    Server->>Middle: 真私钥加密 good
    Middle->>Middle: 内容篡改
    Middle->>Client: 假私钥加密 bad</pre>

<p>上述问题的根本原因是，浏览器无法确认收到的公钥是不是网站自己的, 因为公钥本身是明文传输的</p>
<blockquote>
<p>所有证明的源头都是一条或多条不证自明的“公理”，若想证明某身份证号一定是小明的，可以看他身份证，而身份证是由政府作证的，这里的“公理”就是“政府机构可信”，这也是社会正常运作的前提</p>
</blockquote>
<p>CA 机构（CA，Certificate Authority，证书认证机构）是如今互联网世界正常运作的前提，而 CA 机构颁发的“身份证”就是数字证书</p>
<p>网站在使用 HTTPS 前，需要向 CA 机构申领一份数字证书，数字证书里含有 <strong>证书持有者、域名、公钥、过期时间等信息</strong>，服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，那“证书本身的传输过程中，如何防止被篡改？”</p>
<p>把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫数字签名：</p>
<ol>
<li>CA 机构拥有非对称加密的私钥和公钥</li>
<li>CA 机构对证书明文数据 T 进行 hash <strong>（完整性）</strong></li>
<li>对 hash 后的值用私钥加密，得到数字签名 S</li>
</ol>
<p>明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了，数字证书是为了证明某公钥是可信的，即“该公钥是否对应该网站”<strong>（身份认证）</strong></p>
<p><strong>拥有 CA 的公钥</strong> 是验证数字证书真伪的关键，浏览器通常内置了多个受信任的 CA 的公钥，以便自动验证网站的数字证书，浏览器收到该证书后会校验证书原文的 hash 和签名解密后的 hash 值是否一致</p>
<blockquote>
<p>CA 机构的公钥本身也可以用数字证书来证明，操作系统、浏览器本身会预装一些它们信任的根证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份（信任链或数字证书链）</p>
<p>从整个流程来看，HTTPS 安全性的关键在于根证书是否被篡改。如果根证书被篡改，那么信息传递也就不再是‘绝对’安全的</p>
</blockquote>
<p><strong>HTTPS 优化实践</strong></p>
<ul>
<li><p><strong>使用 TLS1.3 协议</strong></p>
<ul>
<li>2018 年发布的 TLS 1.3 协议优化了 SSL 握手过程，<strong>将握手时间缩短至 1 次 RTT</strong>，如果复用之前的连接，甚至可以实现 0 RTT</li>
</ul>
</li>
<li><p><strong>使用 ECC 证书</strong></p>
<ul>
<li>HTTPS 数字证书分为 RSA 证书和 ECC 证书，二者的区别在于：<ul>
<li>RSA 证书使用的是 RSA 算法生成的公钥，兼容性好，但不支持 PFS（Perfect Forward Secrecy，完美前向保密，保证即使私钥泄露，也无法破解泄露之前通信内容）</li>
<li>ECC 证书使用的是椭圆曲线算法（Elliptic Curve Cryptography）生成的公钥，它的 <strong>计算速度快，安全性高</strong>，支持 PFS，能以 <strong>更小的密钥长度提供更高的安全性</strong></li>
</ul>
</li>
<li>相较于 RSA 证书，ECC 证书的唯一缺点是兼容性稍差，例如 Android 4.0 以上版本才能支持 ECC 证书</li>
<li>ECC 证书的生效与客户端和服务端协商的密码套件（Cipher Suite）直接相关，密码套件决定了通信双方使用的加密、认证算法和密钥交换算法</li>
</ul>
</li>
<li><p>调整 https 会话缓存</p>
<ul>
<li>在 HTTPS 连接建立后，会生成一个 session，用于保存客户端和服务器之间的安全连接信息，如果 session 未过期，后续连接可以复用先前的握手结果，从而提高连接效率</li>
</ul>
</li>
<li><p>开启 OCSP stapling</p>
<ul>
<li>客户端在首次下载数字证书时会向 CA 发起 OCSP（在线证书状态协议）请求，以验证证书是否被撤销或过期</li>
<li>OCSP Stapling 是一种 TLS 扩展，它将 OCSP 查询的工作交由服务器处理，服务器会预先获取 OCSP 响应并将其缓存</li>
<li>当客户端发起 TLS 握手请求时，服务器将证书的 OCSP 信息与证书链一起发送给客户端，从而避免了客户端在验证证书时可能出现的阻塞问题</li>
</ul>
</li>
<li><p>使用 <a target="_blank" rel="noopener" href="https://myssl.com/">https://myssl.com/</a> 服务验证优化是否生效</p>
</li>
</ul>
<h2 id="第三章：深入-Linux-内核网络技术"><a href="#第三章：深入-Linux-内核网络技术" class="headerlink" title="第三章：深入 Linux 内核网络技术"></a>第三章：深入 Linux 内核网络技术</h2><h3 id="OSI-网络分层模型"><a href="#OSI-网络分层模型" class="headerlink" title="OSI 网络分层模型"></a>OSI 网络分层模型</h3><table>
<thead>
<tr>
<th align="left">层级</th>
<th align="left">名称</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">7</td>
<td align="left">应用层（Application Layer）</td>
<td align="left">应用层是 OSI 模型的顶层，直接与用户的应用程序交互，提供网络服务如电子邮件、文件传输、网页浏览等，常见的应用层协议有 HTTP、FTP、SMTP 等</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">表示层（Presentation Layer）</td>
<td align="left">表示层负责数据的格式化和转换，确保发送方和接收方能够理解彼此传输的数据格式，它还处理数据的加密、解密和压缩等操作</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">会话层（Session Layer）</td>
<td align="left">会话层管理应用程序之间的会话或连接，负责建立、维护和终止通信会话，它还提供会话恢复功能，使得通信中断后可以从上次中断的位置继续传输</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">传输层（Transport Layer）</td>
<td align="left">传输层负责端到端的数据传输管理，提供可靠的传输服务，如数据分段、重组、流量控制和错误校正等，常见的传输层协议有 TCP 和 UDP</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">网络层（Network Layer）</td>
<td align="left">网络层负责不同网络之间的数据路由和转发，它使用 IP 地址来确定数据包的传输路径，并确保数据能够从源设备传输到目的设备，即使它们位于不同的网络中</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">数据链路层（Data Link Layer）</td>
<td align="left">数据链路层负责节点之间的数据传输，提供错误检测和纠正功能，它确保数据帧能够在同一局域网（LAN）内可靠传输，数据链路层使用 MAC（Media Access Control，介质访问控制）地址来标识网络上的设备</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">物理层（Physical Layer）</td>
<td align="left">物理层是 OSI 模型的第一层，负责实际的硬件传输，如电缆、光纤、开关和集线器等，它处理二进制数据（即 bit）在物理介质上的传输，包括信号的电气&#x2F;光学特性、传输速率和传输模式等</td>
</tr>
</tbody></table>
<p>数据链路层的数据单元被称为 <strong>帧（Frames）</strong>，网络层的数据单元为称为 <strong>数据包（Packets）</strong>，传输层的数据单元被称为 <strong>数据段（Segments）</strong>，应用层数据单元被称为 <strong>数据（Data）</strong>，用“数据包”泛指以上数据单元</p>
<h3 id="Linux-系统收包流程"><a href="#Linux-系统收包流程" class="headerlink" title="Linux 系统收包流程"></a>Linux 系统收包流程</h3><p>数据包进入网卡（eth0）后，Linux 内核中各个模块相互协作</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/hcjjj/blog-img/networking-CafBaqd-.svg" fancybox="true"/></div></div>

<ol>
<li>当外部网络发送数据包到服务器时，首先由网卡 eth0 接收该数据包</li>
<li>网卡通过 <strong>DMA</strong>（Direct Memory Access，直接内存访问）技术，将数据包直接拷贝到内核中的 <strong>RingBuffer</strong>（环形缓冲区）等待 CPU 处理<ul>
<li>RingBuffer 是一种首尾相接的环形数据结构，它的主要作用是作为缓冲区，缓解网卡接收数据的速度快于 CPU 处理数据的速度问题</li>
</ul>
</li>
<li>数据包成功写入 RingBuffer 后，网卡产生 IRQ（Hardware Interrupt Request，<strong>硬件中断</strong>），通知内核有新的数据包到达</li>
<li>内核收到硬件中断后，立即调用对应的中断处理函数，通常情况下，中断处理函数会简单地标记有新数据到达，并唤醒 ksoftirqd 内核线程来处理 <strong>软中断</strong>（SoftIRQ）</li>
<li>软中断处理过程中，<strong>内核调用网卡驱动</strong> 提前在内核中注册的 NAPI（New API）poll 接口，<strong>从 RingBuffer 中提取数据包，并生成 skb（Socket Buffer）数据</strong><ul>
<li>skb 是 Linux 内核中用于管理网络数据包的主要结构，它包含了网络包的所有信息，包括头部、数据负载等，并在内核的各个网络协议层之间传递</li>
</ul>
</li>
<li>skb 被传递到内核协议栈中进行处理。这里涉及多个网络层次的处理操作：<ul>
<li>网络层（L3 Network layer）：根据主机中的路由表，判断数据包路由到哪一个网络接口（Network Interface），这里的网络接口可能是稍后介绍的虚拟设备，也可能是物理网卡 eth0 接口</li>
<li>传输层（L4 Transport layer）：如解&#x2F;封数据包，处理网络地址转换（NAT）、连接跟踪（conntrack）等操作</li>
</ul>
</li>
<li>内核协议栈处理完成后，数据包被传递到 <strong>socket 接收缓冲区</strong>，应用程序随后利用 <strong>系统调用</strong>（如 Socket API）从缓冲区中读取数据</li>
</ol>
<p>数据包的处理流在不同层级之间需要进行多次上下文切换和拷贝操作，导致延迟增加，对于处理大规模并发连接的网络密集型系统，Linux 内核造成的瓶颈就变得不可忽视，除了优化内核网络协议栈外，业界出现了“绕过内核”这一思想的技术，例如 XDP 和 DPDK 技术</p>
<h2 id="第四章：负载均衡技术"><a href="#第四章：负载均衡技术" class="headerlink" title="第四章：负载均衡技术"></a>第四章：负载均衡技术</h2><h3 id="负载均衡概述"><a href="#负载均衡概述" class="headerlink" title="负载均衡概述"></a>负载均衡概述</h3><pre class="mermaid">graph LR
    Client([Clients]) --> LB([Load Balancer])
    LB --> RS1([RealServer1])
    LB --> RS2([RealServer2])
    LB --> RS3([RealServer3])
    
    %% 节点样式
    style Client fill:#C0C0C0,stroke:#333,stroke-width:2px
    style LB fill:#FFD700,stroke:#333,stroke-width:2px
    style RS1 fill:#ADD8E6,stroke:#333,stroke-width:2px
    style RS2 fill:#ADD8E6,stroke:#333,stroke-width:2px
    style RS3 fill:#ADD8E6,stroke:#333,stroke-width:2px
    
    %% 箭头样式
    linkStyle default stroke:#333,stroke-width:2px</pre>



<p>从整体架构来看，中间的 <strong>负载均衡器</strong> 承担下述职责：</p>
<ul>
<li><strong>服务发现</strong>：识别系统中可用的后端服务器，并获取它们的地址，以便负载均衡器与后端通信</li>
<li><strong>健康检查</strong>：确定哪些后端服务器处于健康状态并能够接收请求</li>
<li><strong>负载均衡</strong>：基于适当的算法将请求均匀分配到健康的后端服务器上</li>
</ul>
<p>合理使用负载均衡能为分布式系统带来诸多好处：</p>
<ul>
<li>命名抽象：客户端通过预设机制（如 DNS 或内置库）访问负载均衡器，而 <strong>无需了解后端服务器的拓扑结构或配置</strong></li>
<li>容错：通过健康检查和多种负载均衡算法，将请求均匀转发至正常的后端服务器，故障服务器则会被移出 <strong>负载均衡池</strong>，便于运维人员从容修复</li>
<li>成本和性能收益：分布式系统通常是异构的，后端服务器分布在多个网络区域（Zone&#x2F;Region），负载均衡器通过策略 <strong>优先将请求保持在同一网络区域内</strong>，从而提高服务性能（减少延迟）并降低资源成本（减少跨区域带宽费用）</li>
</ul>
<p>从网络层处理请求的层面看，所有的负载均衡可总结为两类：</p>
<ul>
<li>四层负载均衡（比如 K8s 的 Service， K8s 是在应用层通过抽象和控制维护了一个集群内的“虚拟网络系统”）<ul>
<li>并非仅指其在 OSI 模型的第四层传输层工作</li>
<li>而是指四层负载均衡所有工作模式的共同特点是，维持传输层连接（如 TCP、UDP）特性</li>
<li>沿用惯例，来自客户端的请求，无论是在网络层处理，还是在传输层的处理，统称为四层负载均衡处理</li>
</ul>
</li>
<li>七层负载均衡（比如 K8s 的 Ingress）</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">四层负载均衡（L4）</th>
<th align="left">七层负载均衡（L7）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">工作层次</td>
<td align="left">传输层（TCP&#x2F;UDP）</td>
<td align="left">应用层（HTTP&#x2F;HTTPS）</td>
</tr>
<tr>
<td align="left">处理速度</td>
<td align="left">较快（在内核层面处理，低延迟）</td>
<td align="left">相对较慢（增加了应用层的处理开销）</td>
</tr>
<tr>
<td align="left">灵活性</td>
<td align="left">较低，基于 IP 和端口进行路由</td>
<td align="left">高，基于内容、请求头等进行路由</td>
</tr>
<tr>
<td align="left">功能</td>
<td align="left">主要实现流量分发</td>
<td align="left">支持内容缓存、内容路由、SSL 终止（SSL Termination）等高级功能</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">实时应用、简单的 TCP&#x2F;UDP 服务</td>
<td align="left">Web 应用、微服务架构、复杂请求处理</td>
</tr>
</tbody></table>
<h3 id="负载均衡调度算法"><a href="#负载均衡调度算法" class="headerlink" title="负载均衡调度算法"></a>负载均衡调度算法</h3><p>负载均衡的另一个重要职责：“选择谁来处理用户请求”，也就是负载均衡器所采用的调度算法</p>
<p>一些常见的负载均衡算法：</p>
<ul>
<li><strong>轮询均衡算法</strong>（Round-Robin）：按依次循环的方式将请求调度到不同的服务器上<ul>
<li>该算法最大的特点是实现简单，轮询算法假设所有的服务器处理请求的能力都一样</li>
<li>调度器会将所有的请求平均分配给每个真实服务器</li>
</ul>
</li>
<li><strong>随机均衡算法</strong>（Random）：此种负载均衡算法类似于轮询调度，不过在分配处理请求时是随机的过程<ul>
<li>由概率论可以得知，随着客户端调用服务端的次数增多，其实际效果趋近于平均分配请求到服务端的每一台服务器也就是达到轮询的效果</li>
</ul>
</li>
<li><strong>最小连接均衡算法</strong>（Least-Connection）：该算法中 <strong>调度器需要记录各个服务器已建立连接的数量</strong>，然后把新的连接请求分配到当前连接数最小的服务器<ul>
<li>最小连接均衡算法特别适合于服务器处理时间不一致的场景</li>
<li>例如，当某些请求可能占用较长时间，而另一些请求很快就会完成时，最小连接算法可以有效避免某些服务器因处理大量复杂请求而过载</li>
</ul>
</li>
<li><strong>哈希均衡算法</strong>（Consistency Hash）：将请求中的某些特征数据（例如 IP、MAC 或者更上层应用的某些信息）作为特征值来计算需要落在的节点<ul>
<li>哈希算法会保证同一个特征值的请求每一次都会落在相同的服务器上</li>
<li>一致性哈希是一种改进的哈希算法，设计目的是解决传统哈希均衡在节点增减时的 <strong>重分布</strong> 问题</li>
</ul>
</li>
</ul>
<p>不考虑服务器的处理能力的负载均衡算法，实际上是一种“伪均衡”算法，考虑各个服务器的处理能力存在差异，负载均衡算法又有了对服务器“<strong>加权</strong>”的补充</p>
<h3 id="负载均衡拓扑类型"><a href="#负载均衡拓扑类型" class="headerlink" title="负载均衡拓扑类型"></a>负载均衡拓扑类型</h3><p><strong>中间代理拓扑</strong></p>
<pre class="mermaid">graph LR
    Client([Client]) --> LB([Load Balancer])
    LB --> RS1([RealServer1])
    LB --> RS2([RealServer2])
    LB --> RS3([RealServer3])
    
    %% 节点样式
    style Client fill:#C0C0C0,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style LB fill:#FFD700,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style RS1 fill:#ADD8E6,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style RS2 fill:#ADD8E6,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style RS3 fill:#ADD8E6,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    
    %% 箭头样式
    linkStyle default stroke:#333,stroke-width:2px</pre>

<p>典型的中间代理拓扑的方案有：</p>
<ul>
<li>硬件设备：Cisco、Juniper、F5 Networks 等公司的产品</li>
<li>云软件解决方案：阿里云的 SLB（Server Load Balancer），AWS 的 ELB（Elastic Load Balancer）、Azure 的 Load Balancer 和 Google Cloud 的 Cloud Load Balancing 等</li>
<li>纯软件方案：Nginx、HAProxy、Envoy 等</li>
</ul>
<p>中间代理模式的优点在于简单，<strong>用户只需通过 DNS 连接到负载均衡器，无需关注其他细节</strong>，缺点是，<strong>中间代理可能存在单点故障风险</strong>，尤其是负载均衡这种集中式的设计，如果负载均衡器出现问题，会导致整个系统的访问中断</p>
<p><strong>边缘代理拓扑（中间代理拓扑的一个变种）</strong></p>
<pre class="mermaid">graph LR
    Client([Client]) --> Internet([Internet])
    Internet --> LB([Load Balancer])
    LB --> RS1([RealServer1])
    LB --> RS2([RealServer2])
    LB --> RS3([RealServer3])
    
    %% 节点样式
    style Client fill:#C0C0C0,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style Internet fill:#F5F5F5,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5,rx:10px,ry:10px
    style LB fill:#FFD700,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style RS1 fill:#ADD8E6,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style RS2 fill:#ADD8E6,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style RS3 fill:#ADD8E6,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    
    %% 箭头样式
    linkStyle default stroke:#333,stroke-width:2px</pre>

<p><strong>将负载均衡器以 SDK 库的形式嵌入到客户端</strong></p>
<pre class="mermaid">graph LR
    subgraph Client
        Service[Service]:::service
        ClientLibrary[Client library]:::client
    end
    ClientLibrary --> RS1[RealServer1]
    ClientLibrary --> RS2[RealServer2]
    ClientLibrary --> RS3[RealServer3]

    %% 样式定义
    classDef service fill:#FFFFFF,stroke:#333,stroke-width:2px,rx:5px,ry:5px
    classDef client fill:#C0C0C0,stroke:#333,stroke-width:2px,rx:5px,ry:5px
    style Client fill:none,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style RS1 fill:#ADD8E6,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style RS2 fill:#ADD8E6,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style RS3 fill:#ADD8E6,stroke:#333,stroke-width:2px,rx:10px,ry:10px

    %% 箭头样式
    linkStyle default stroke:#333,stroke-width:2px</pre>

<p><strong>Sidecar 拓扑（客户端内嵌库拓扑的一个变种）</strong></p>
<pre class="mermaid">graph LR
    subgraph Container
        Service[Service]
        Sidecar[Sidecar Proxy]:::sidecar
        Service <--> Sidecar
    end
    Sidecar --> RS1[RealServer1]
    Sidecar --> RS2[RealServer2]
    Sidecar --> RS3[RealServer3]

    %% 节点样式
    style Service fill:#FFFFFF,stroke:#333,stroke-width:2px,rx:5px,ry:5px
    style Sidecar fill:#C0C0C0,stroke:#333,stroke-width:2px,rx:5px,ry:5px
    style Container fill:none,stroke:#333,stroke-width:2px,rx:15px,ry:15px
    style RS1 fill:#ADD8E6,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style RS2 fill:#ADD8E6,stroke:#333,stroke-width:2px,rx:10px,ry:10px
    style RS3 fill:#ADD8E6,stroke:#333,stroke-width:2px,rx:10px,ry:10px

    %% 箭头样式
    linkStyle default stroke:#333,stroke-width:2px</pre>
<h3 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h3><p>所谓的“四层负载均衡”（Layer 4 Load Balancer，简称 L4），并非仅指其在 OSI 模型的第四层（传输层）工作，而是指四层负载均衡所有工作模式的共同特点是，维持传输层连接（如 TCP、UDP）特性，沿用惯例，来自客户端的请求，无论是在网络层处理，还是在传输层的处理，统称为四层负载均衡处理</p>
<p>四层负载均衡器的不同工作模式涉及多个网络层：</p>
<ul>
<li>在第二层（数据链路层）通过改写 MAC 地址实现请求转发</li>
<li>在第三层（网络层）改写 IP 地址完成请求路由</li>
<li>在第四层（传输层）修改 UDP 或 TCP 的端口和连接地址，并通过 NAT 方式实现请求转发</li>
</ul>
<blockquote>
<p>网络地址转换（Network Address Transform）是指将专用网络地址转换为网络中的公用地址，实现将 <code>公网&#123;IP:PORT&#125;</code> 映射成 <code>内网&#123;IP:PORT&#125;</code></p>
<ul>
<li>由于专用网本地 IP 地址是可重用的，所以 NAT 大大节省了 IP 地址的消耗</li>
</ul>
<ul>
<li>同时，它隐藏了内部网络结构，从而降低了内部网络受到攻击的风险</li>
</ul>
</blockquote>
<p><strong>四层负载均衡工作模式</strong></p>
<ul>
<li>DR 模式</li>
<li>Tunnel 模式</li>
<li>NAT 模式</li>
</ul>
<h3 id="七层负载均衡"><a href="#七层负载均衡" class="headerlink" title="七层负载均衡"></a>七层负载均衡</h3><p>早期的七层负载均衡，仅实现应用层请求的代理，如把非业务功能，如 <strong>路由请求、鉴权、监控、缓存、限流和日志记录</strong> 等集中在一层处理，并在一个控制台统一管理，此即为集群入口的高阶模式 —— <strong>网关（API Gateway）</strong></p>
<table>
<thead>
<tr>
<th align="left">网关</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">OpenResty</td>
<td align="left">基于 Nginx 和 LuaJIT 的高性能 Web 平台。通过 LuaJIT 引擎，用户可以在 Nginx 中编写 Lua 脚本，在请求处理的不同阶段（如请求、响应、重写、日志等）动态地执行自定义逻辑</td>
</tr>
<tr>
<td align="left">Kong</td>
<td align="left">社区活跃、成熟度高、Postgres 存储、二次开发成本高</td>
</tr>
<tr>
<td align="left">Spring Cloud Gateway</td>
<td align="left">Spring Cloud Gateway 是 Spring 生态系统中的一个网关解决方案，适用于 SpringBoot 和 SpringCloud 构建的微服务系统</td>
</tr>
<tr>
<td align="left">Traefik</td>
<td align="left">与 Docker、Kubernetes 等容器编排系统紧密结合</td>
</tr>
<tr>
<td align="left">Envoy</td>
<td align="left">Envoy 是 Lyft 开发的一款面向服务网格的高性能网络代理，支持高级的路由控制、负载均衡策略、服务发现和健康检查等，Envoy 与 Istio 等服务网格解决方案紧密结合，通常作为它们的数据平面代理使用</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>协议支持</strong>：网关对应用层协议了解的越多，就可以处理更复杂的事情，如系统可观测、高级负载均衡和路由等</p>
<ul>
<li>云原生网关的典型代表 Envoy 支持如下七层协议的解析和路由：HTTP&#x2F;1、HTTP&#x2F;2、gRPC、Redis、MongoDB、DynamoDB 等等</li>
</ul>
</li>
<li><p><strong>动态配置</strong>： 服务管理的动态配置包括路由、上游服务（Upstream）、SSL 证书、消费者等，数据的替换和更新不会产生任何中断，从而将线上流量的影响降低到最低</p>
</li>
<li><p><strong>SSL 卸载</strong>：通过 SSL 卸载将业务的 SSL 协商以及加解密处理从原来的服务器迁移到负载均衡设备上来，从而减轻服务器的 SSL 协商以及加解密的工作负担</p>
</li>
<li><p><strong>流量治理</strong>：微服务架构中，服务间的通信治理是必不可少的环节，如超时、重试、限速、熔断、流量镜像、缓存等等</p>
<ul>
<li>现代网关系统在服务以及流量的管理上可对多业务进行收敛统一处理，降低多套网关的运维成本</li>
</ul>
</li>
<li><p><strong>可观测性</strong>：传统的监控方式已经无法适应云原生的场景，服务治理的可观测性输出是网关系统提供的最重要的特性</p>
<ul>
<li>系统度量、分布式跟踪以及自定义日志等功能现在几乎是七层负载均衡解决方案的标配</li>
<li>需丰富的可观测数据并不是没有代价的，负载均衡器需要做一些额外的工作才能产生这些数据</li>
<li>但是这些数据带来的收益要远远大于为产生它们而增加的那点性能损失</li>
</ul>
</li>
<li><p><strong>可扩展性</strong>：例如典型网关 OpenResty，通过编写可插拔的插件能够轻松地对网关系统实现各种流量处理以及各类自定义功能</p>
<ul>
<li>譬如流量限速、日志记录、安全检测、故障注入等等</li>
</ul>
</li>
<li><p><strong>高可用以及无状态设计</strong>：现代网关系统不仅提供数据面实现，还提供控制面实现，二者目标都在朝向无状态设计，可以轻松地实现水平扩展，网关架构整体上也默认高可用，不存在单点故障</p>
</li>
</ul>
<h2 id="第五章：数据一致性与分布式事务"><a href="#第五章：数据一致性与分布式事务" class="headerlink" title="第五章：数据一致性与分布式事务"></a>第五章：数据一致性与分布式事务</h2><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><h3 id="一致性与可用性的权衡"><a href="#一致性与可用性的权衡" class="headerlink" title="一致性与可用性的权衡"></a>一致性与可用性的权衡</h3><h3 id="分布式事务模型"><a href="#分布式事务模型" class="headerlink" title="分布式事务模型"></a>分布式事务模型</h3><h3 id="服务幂等性设计"><a href="#服务幂等性设计" class="headerlink" title="服务幂等性设计"></a>服务幂等性设计</h3><h2 id="第六章：分布式共识及算法"><a href="#第六章：分布式共识及算法" class="headerlink" title="第六章：分布式共识及算法"></a>第六章：分布式共识及算法</h2><h2 id="第七章：容器编排技术"><a href="#第七章：容器编排技术" class="headerlink" title="第七章：容器编排技术"></a>第七章：容器编排技术</h2><h2 id="第八章：服务网格技术"><a href="#第八章：服务网格技术" class="headerlink" title="第八章：服务网格技术"></a>第八章：服务网格技术</h2><h2 id="第九章：系统可观测性"><a href="#第九章：系统可观测性" class="headerlink" title="第九章：系统可观测性"></a>第九章：系统可观测性</h2><h2 id="第十章-GitOps-理念与实现设计"><a href="#第十章-GitOps-理念与实现设计" class="headerlink" title="第十章 GitOps 理念与实现设计"></a>第十章 GitOps 理念与实现设计</h2>

<!-- 
<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div> -->

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/11/04/phoenix/">《凤凰架构：构建可靠的大型分布式系统》🪽</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/10/15/k8s/">Kubernetes 基础概念与原理解析 ☸</a></div></section></div>






  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" data-repo="hcjjj/blog-comments" data-repo-id="R_kgDOM8H5Mg" data-category="Announcements" data-category-id="DIC_kwDOM8H5Ms4CjGw7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>



      <!-- 
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@anonymity</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer> -->

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadJS() {
    const els = document.querySelectorAll("#comments #giscus");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://giscus.app/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    loadJS();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
